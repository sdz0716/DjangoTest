

__init__.py ：让 Python 把该目录当成一个开发包 (即一组模块)所需的文件。 这是一个空文件，一般你不需要修改它。

manage.py ：一种命令行工具，允许你以多种方式与该 Django 项目进行交互。 键入python manage.py help，看一下它能做什么。 你应当不需要编辑这个文件；在这个目录下生成它纯是为了方便。

settings.py ：该 Django 项目的设置或配置。 查看并理解这个文件中可用的设置类型及其默认值。

urls.py：Django项目的URL设置。 可视其为你的django网站的目录。 目前，它是空的。

页面的内容是靠view function（视图函数） 来产生，URL定义在 URLconf 中.一个视图就是Python的一个函数。这个函数第一个参数的类型是HttpRequest；它返回一个HttpResponse实例。为了使一个Python的函数成为一个Django可识别的视图，它必须满足这两个条件。 （也有例外，但是我们稍后才会接触到。

匹配网站根目录的URL模式, ('^$', my_homepage_view)

【模板系统：HTML模板】
Django模板系统的基本规则： 写模板，创建 Template 对象，创建 Context ， 调用 render() 方法。

from django import template
t = template.Template('my name is {{ name }}.')
c = template.Context({'name': 'Ada'})
t.render(c)
Out[6]:
'my name is Ada.'

【编写模板并渲染的示例：】
>>> from django.template import Template, Context
>>> raw_template = """<p>Dear {{ person_name }},</p>
...
... <p>Thanks for placing an order from {{ company }}. It's scheduled to
... ship on {{ ship_date|date:"F j, Y" }}.</p>
...
... {% if ordered_warranty %}
... <p>Your warranty information will be included in the packaging.</p>
... {% else %}
... <p>You didn't order a warranty, so you're on your own when
... the products inevitably stop working.</p>
... {% endif %}
...
... <p>Sincerely,<br />{{ company }}</p>"""
>>> t = Template(raw_template)
>>> import datetime
>>> c = Context({'person_name': 'John Smith',
...     'company': 'Outdoor Equipment',
...     'ship_date': datetime.date(2009, 4, 2),
...     'ordered_warranty': False})
>>> t.render(c)
u"<p>Dear John Smith,</p>\n\n<p>Thanks for placing an order from Outdoor
Equipment. It's scheduled to\nship on April 2, 2009.</p>\n\n\n<p>You
didn't order a warranty, so you're on your own when\nthe products
inevitably stop working.</p>\n\n\n<p>Sincerely,<br />Outdoor Equipment
</p>"

【一旦有了 模板 对象，你就可以通过它渲染多个context】， 例如：
t = Template('Hello, {{ name }}')
for name in ('John', 'Julie', 'Pat'):
    print t.render(Context({'name': name}))

 比如，假设你要向模板传递一个 Python 字典。 要通过字典键访问该字典的值:
 >>> from django.template import Template, Context
>>> person = {'name': 'Sally', 'age': '43'}
>>> t = Template('{{ person.name }} is {{ person.age }} years old.')
>>> c = Context({'person': person})
>>> t.render(c)
u'Sally is 43 years old.'

【也可以通过句点来访问对象的属性。】 比方说， Python 的 datetime.date 对象有 year 、 month 和 day 几个属性，你同样可以在模板中使用句点来访问这些属性：
>>> t = Template('The month is {{ date.month }} and the year is {{ date.year }}.')
>>> c = Context({'date': d})
>>> t.render(c)
u'The month is 5 and the year is 1993.'

【自定义类：】
class Person():
    def __init__(self, firstName, lastName):
        self.firstName, self.lastName = firstName, lastName

t = template.Template('hello, {{person.firstName}} {{person.lastName}}.')
c = template.Context({'person': Person('john', 'Smith')})
t.render(c)
Out[16]:
'hello, john Smith.'

【点语法也可以用来引用对象的* 方法*。】 例如，每个 Python 字符串都有 upper() 和 isdigit() 方法，你在模板中可以使用同样的句点语法来调用它们：
t = template.Template('{{ var }} -- {{ var.upper }} -- {{ var.isdigit }}')
c = template.Context({'var': 'hello'})
t.render(c)
Out[19]:
'hello -- HELLO -- False'
t.render(template.Context({'var': '123'}))
Out[20]:
'123 -- 123 -- True'
注意这里调用方法时并* 没有* 使用圆括号 而且也无法给该方法传递参数；你只能调用不需参数的方法。

【句点也可用于访问列表索引:】
>>> from django.template import Template, Context
>>> t = Template('Item 2 is {{ items.2 }}.')
>>> c = Context({'items': ['apples', 'bananas', 'carrots']})
>>> t.render(c)
'Item 2 is carrots.'
不允许使用负数列表索引。 像 {{ items.-1 }} 这样的模板变量将会引发`` TemplateSyntaxError``

句点查找规则可概括为： 当模板系统在变量名中遇到点时，按照以下顺序尝试进行查找：
    字典类型查找 （比如 foo["bar"] )
    属性查找 (比如 foo.bar )
    方法调用 （比如 foo.bar() )
    列表类型索引查找 (比如 foo[bar] )
系统使用找到的第一个有效类型.

【句点查找可以多级深度嵌套】。 例如在下面这个例子中 {{person.name.upper}} 会转换成字典类型查找（ person['name'] ) 然后是方法调用（ upper() ):
>>> from django.template import Template, Context
>>> person = {'name': 'Sally', 'age': '43'}
>>> t = Template('{{ person.name.upper }} is {{ person.age }} years old.')
>>> c = Context({'person': person})
>>> t.render(c)
'SALLY is 43 years old.'

默认情况下，如果一个变量不存在，模板系统会把它展示为空字符串，不做任何事情来表示失败。

多数时间，你可以通过传递一个完全填充(full populated)的字典给 Context() 来初始化 上下文(Context) 。 但是初始化以后，你也可以使用标准的Python字典语法(syntax)向``上下文(Context)`` 对象添加或者删除条目.
>>> c = Context({"foo": "bar"})
>>> c['foo']
'bar'
>>> del c['foo']
>>> c['foo']
Traceback (most recent call last):

【标签】
{% if %} 标签接受 and ， or 或者 not 关键字来对多个变量做判断 ，或者对变量取反（ not )，不允许在同一个标签中同时使用 and 和 or.系统不支持用圆括号来组合比较操作。
一定要用 {% endif %} 关闭每一个 {% if %} 标签。

{% for %}允许我们在一个序列上迭代. 每一次循环中，模板系统会渲染在 {% for %} 和 {% endfor %} 之间的所有内容。
<ul>
{% for athlete in athlete_list %}
    <li>{{ athlete.name }}</li>
{% endfor %}
</ul>

给标签增加一个 reversed 使得该列表被反向迭代：
{% for athlete in athlete_list reversed %}
...
{% endfor %}

`` for`` 标签支持一个可选的`` {% empty %}`` 分句:
{% for athlete in athlete_list %}
    <p>{{ athlete.name }}</p>
{% empty %}
    <p>There are no athletes. Only computer programmers.</p>
{% endfor %}

Django不支持退出循环操作。 如果我们想退出循环，可以改变正在迭代的变量。Django也不支持continue语句，我们无法让当前迭代操作跳回到循环头部。

forloop 变量仅仅能够在循环中使用。 在模板解析器碰到{% endfor %}标签后，forloop就不可访问了。
forloop.counter 总是一个表示当前循环的执行次数的整数计数器。 这个计数器是从1开始的。
{% for item in todo_list %}
    <p>{{ forloop.counter }}: {{ item }}</p>
{% endfor %}
forloop.counter0 类似于 forloop.counter ，但是它是从0计数的。 第一次执行循环时这个变量会被设置为0。
forloop.revcounter 是表示循环中剩余项的整型变量。 在循环初次执行时 forloop.revcounter 将被设置为序列中项的总数。 最后一次循环执行中，这个变量将被置1。
forloop.revcounter0 类似于 forloop.revcounter ，但它以0做为结束索引。 在第一次执行循环时，该变量会被置为序列的项的个数减1。
forloop.first 是一个布尔值，如果该迭代是第一次执行，那么它被置为True。
forloop.last 是一个布尔值；在最后一次执行循环时被置为True。
forloop.parentloop 是一个指向当前循环的上一级循环的 forloop 对象的引用（在嵌套循环的情况下）。

【ifequal/ifnotequal】
{% ifequal %} 标签比较两个值，当他们相等时，显示在 {% ifequal %} 和 {% endifequal %} 之中所有的值。只有模板变量，字符串，整数和小数可以作为 {% ifequal %} 标签的参数。
下面的例子比较两个模板变量 user 和 currentuser :
{% ifequal user currentuser %}
    <h1>Welcome!</h1>
{% endifequal %}

参数可以是硬编码的字符串，随便用单引号或者双引号引起来，所以下列代码都是正确的：
{% ifequal section 'sitenews' %}
    <h1>Site News</h1>
{% endifequal %}

{% ifequal section "community" %}
    <h1>Community</h1>
{% endifequal %}

和 {% if %} 类似， {% ifequal %} 支持可选的 {% else%} 标签：
{% ifequal section 'sitenews' %}
    <h1>Site News</h1>
{% else %}
    <h1>No News Here</h1>
{% endifequal %}

【注释】
Django模板语言同样提供代码注释。 注释的内容不会在模板渲染时输出。注释使用 {# #} ：
{# This is a comment #}

多行注释，可以使用`` {% comment %}`` 模板标签：
{% comment %}
This is a
multi-line comment.
{% endcomment %}

【过滤器】
过滤器使用管道字符。如 {{ name|lower }} ，显示的内容是变量 {{ name }} 被过滤器 lower 处理后的结果，它功能是转换文本为小写。

{{ my_list|first|upper }} 实现查找列表的第一个元素并将其转化为大写。

有些过滤器有参数。 过滤器的参数跟随冒号之后并且总是以双引号包含。 例如：{{ bio|truncatewords:"30" }} ，将显示变量 bio 的前30个词。

addslashes : 添加反斜杠到任何反斜杠、单引号或者双引号前面。 这在处理包含JavaScript的文本时是非常有用的。
date : 按指定的格式字符串参数格式化 date 或者 datetime 对象， 范例：{{ pub_date|date:"F j, Y" }}
length : 返回变量的长度。 对于列表，这个参数将返回列表元素的个数。 对于字符串，这个参数将返回字符串中字符的个数。 你可以对列表或者字符串，或者任何知道怎么测定长度的Python 对象使用这个方法。

【模板加载】
见views.py
方法二，通过get_template导入模板
方法三，通过django.shortcuts的render_to_response模块直接返回数据。

locals() 技巧
我们没有像之前那样手工指定 context 字典，而是传入了 locals() 的值，它囊括了函数执行到该时间点时所定义的一切变量。 因此，我们将 now 变量重命名为 current_date ，因为那才是模板所预期的变量名称。
使用 locals() 时要注意是它将包括 所有 的局部变量，它们可能比你想让模板访问的要多。 在前例中， locals() 还包含了 request 。
def current_datetime(request):
    now = datetime.datetime.now()
    return render_to_response('current_datetime.html', {'current_date': now})
可写为
def current_datetime(request):
    current_date = datetime.datetime.now()
    return render_to_response('current_datetime.html', locals())

【get_template()中使用子目录】
只需在调用 get_template() 时，把子目录名和一条斜杠添加到模板名称之前。对子目录树的深度没有限制。
t = get_template('dateapp/current_datetime.html')
return render_to_response('dateapp/current_datetime.html', {'current_date': now})

【include 模板标签】
{% include %}该标签允许在（模板中）包含其它的模板的内容。 标签的参数是所要包含的模板名称，可以是一个变量，也可以是用单/双引号硬编码的字符串。
{% include 'nav.html' %}
{% include "nav.html" %}
{% include 'includes/nav.html' %}
{% include template_name %}  以变量 template_name 的值为名称的模板

【模板继承】
可以对那些 不同 的代码段进行定义，而不是 共同 代码段。见base.html
见views.py的current_datetime和hours_ahead函数，注意函数中的变量需要与对应的html中的变量相匹配。
对应的html文件中{% extends %} 标签注明此为子模板。
由于子模板并没有定义 footer 块，模板系统将使用在父模板中定义的值。 父模板 {% block %} 标签中的内容总是被当作一条退路。

使用继承的一种常见方式是下面的三层法：
1，创建 base.html 模板，在其中定义站点的主要外观感受。 这些都是不常修改甚至从不修改的部分。
2，为网站的每个区域创建 base_SECTION.html 模板(例如, base_photos.html 和 base_forum.html )。这些模板对 base.html 进行拓展，并包含区域特定的风格与设计。
3，为每种类型的页面创建独立的模板，例如论坛页面或者图片库。 这些模板拓展相应的区域模板。

使用模板继承的一些诀窍：
1，如果在模板中使用 {% extends %} ，必须保证其为模板中的第一个模板标记。 否则，模板继承将不起作用。
2，基础模板中的 {% block %} 标签越多越好。 记住，子模板不必定义父模板中所有的代码块，因此你可以用合理的缺省值对一些代码块进行填充，然后只对子模板所需的代码块进行（重）定义。
3，如果发觉自己在多个模板之间拷贝代码，你应该考虑将该代码段放置到父模板的某个 {% block %} 中。
4，如果你需要访问父模板中的块的内容，使用 {{ block.super }}这个标签吧，这一个魔法变量将会表现出父模板中的内容。 如果只想在上级代码块基础上添加内容，而不是全部重载，该变量就显得非常有用了
5,不允许在同一个模板中定义多个同名的 {% block %}
6,{% extends %} 对所传入模板名称使用的加载方法和 get_template() 相同。 也就是说，会将模板名称被添加到 TEMPLATE_DIRS 设置之后。
7,多数情况下， {% extends %} 的参数应该是字符串，但是如果直到运行时方能确定父模板名，这个参数也可以是个变量。 这使得你能够实现一些很酷的动态功能。


【模型】
 MVC 模式，可以称得上是一种 MVC 框架。 以下是 Django 中 M、V 和 C 各自的含义：
M ，数据存取部分，由django数据库层处理，本章要讲述的内容。
V ，选择显示哪些数据要显示以及怎样显示的部分，由视图和模板处理。
C ，根据用户输入委派视图的部分，由 Django 框架根据 URLconf 设置，对给定 URL 调用适当的 Python 函数。

由于 C 由框架自行处理，而 Django 里更关注的是模型（Model）、模板(Template)和视图（Views），Django 也被称为 MTV 框架 。在 MTV 开发模式中：
M 代表模型（Model），即数据存取层。 该层处理与数据相关的所有事务： 如何存取、如何验证有效性、包含哪些行为以及数据之间的关系等。
T 代表模板(Template)，即表现层。 该层处理与表现相关的决定： 如何在页面或其他类型文档中进行显示。
V 代表视图（View），即业务逻辑层。 该层包含存取模型及调取恰当模板的相关逻辑。 你可以把它看作模型与模板之间的桥梁。

【连接mysql配置】
修改settings.py中的DATABASE字典中的配置。
安装mysqlclient，作为python和Django的接口。
进入python manage.py shell，测试配置。
>>> from django.db import connection
>>> cursor = connection.cursor()

【第一个应用程序APP】
 project 和 app区别就是一个是配置另一个是 代码。一个project包含很多个Django app以及对它们的配置。
技术上，project的作用是提供配置文件，比方说哪里定义数据库连接信息, 安装的app列表， TEMPLATE_DIRS ，等等。
一个app是一套Django功能的集合，通常包括模型和视图，按Python的包结构的方式存在。
例如，Django本身内建有一些app，例如注释系统和自动管理界面。 app的一个关键点是它们是很容易移植到其他project和被多个project复用。
系统对app有一个约定： 如果你使用了Django的数据库层（模型），你 必须创建一个Django app。 模型必须存放在apps中。

新建APP：python manage.py startapp books  会生成books文件夹并包含一些初始文件。

【第一个模型】
“每个数据库表对应一个类”这条规则的例外情况是多对多关系。 在我们的范例模型中， Book 有一个 多对多字段 叫做 authors 。 该字段表明一本书籍有一个或多个作者，但 Book 数据库表却并没有 authors 字段。 相反，Django创建了一个额外的表（多对多连接表）来处理书籍和作者之间的映射关系。
最后需要注意的是，我们并没有显式地为这些模型定义任何主键。 除非你单独指明，否则Django会自动为每个模型生成一个自增长的整数主键字段每个Django模型都要求有单独的主键。id

{以下为1.10.0版本操作，与老版本不同}
编辑 settings.py 文件， 找到 INSTALLED_APPS 设置。添加`` ‘books’`` 到`` INSTALLED_APPS`` 的末尾。
执行如下命令生成数据库表：
1,python manage.py check  检查模型的语法和逻辑是否正确。
2,python manage.py makemigrations 用来检测数据库变更和生成数据库迁移文件
3,python manage.py sqlmigrate demo 0001 用来把数据库迁移文件转换成数据库语言,demo指app名称
4,python manage.py migrate 用于执行迁移动作
注：如果更改models.py内容后，需要重新执行以上命令使数据库内生效。

python manage.py shell 中执行：
>>> p1 = Publisher(name='Apress', address='2855 Telegraph Avenue',
...     city='Berkeley', state_province='CA', country='U.S.A.',
...     website='http://www.apress.com/')
>>> p1.save()       #Django 会在后台执行一条 INSERT 语句。
>>> p2 = Publisher.objects.create(name="O'Reilly",
...     address='10 Fawcett St.', city='Cambridge',
...     state_province='MA', country='U.S.A.',
...     website='http://www.oreilly.com/')      #使用`` objects.create()`` 方法,可以一步完成对象的创建与存储至数据库。
>>> publisher_list      #Django执行了一条SQL `` SELECT`` 语句。
[<Publisher: Publisher object>, <Publisher: Publisher object>]

解决以上输出中Publisher object解码问题，需要在models.py中的每个类中添加 def __str__(): 方法。老版本为添加__unicode__()。
退出manage.py shell后，重新进入
In [1]: from books.models import Publisher
In [2]: Publisher.objects.all()
Out[2]: <QuerySet [<Publisher: Apress>, <Publisher: O'Reilly>, <Publisher: O'Reilly>]>

更新数据库内容：
In [3]: p = Publisher(name='Apress',
   ...:          address='2855 Telegraph Ave.',
   ...:          city='Berkeley',
   ...:          state_province='CA',
   ...:          country='U.S.A.',
   ...:          website='http://www.apress.com/')
In [4]: p.save()
In [5]: p.id
Out[5]: 4
In [6]: p.name = 'Apress Publishing'
In [7]: p.save()
In [8]: p.name
Out[8]: 'Apress Publishing'

数据查询：
调用绑定在该模型上的管理器(objects)的相应方法(如all)。

数据过滤：
>>> Publisher.objects.filter(name='Apress')     #使用filter()
[<Publisher: Apress>]
>>> Publisher.objects.filter(country="U.S.A.", state_province="CA")
[<Publisher: Apress>]
>>> Publisher.objects.filter(name__contains="press")        #相当于mysql中的LIKE，name__contains为双下划线，代表模糊匹配
[<Publisher: Apress>]
其他包括icontains(大小写无关的LIKE),startswith和endswith, 还有range(SQLBETWEEN查询）等。

获取单个对象：
>>> Publisher.objects.get(name="Apress")
<Publisher: Apress>
返回了单个对象，而不是列表（更准确的说，QuerySet)。 所以，如果结果是多个对象，会导致抛出异常。
DoesNotExist 异常 是 Publisher 这个 model 类的一个属性，即 Publisher.DoesNotExist。在你的应用中，你可以捕获并处理这个异常，像这样：
try:
    p = Publisher.objects.get(name='Apress')
except Publisher.DoesNotExist:
    print "Apress isn't in the database yet."
else:
    print "Apress is in the database."

数据排序：
>>> Publisher.objects.order_by("name")
[<Publisher: Apress>, <Publisher: O'Reilly>]
按字母顺序。可以对任意字段进行排序。
>>> Publisher.objects.order_by("state_province", "address")     以多个字段为标准进行排序（第二个字段会在第一个字段的值相同的情况下被使用到），使用多个参数就可以。
 [<Publisher: Apress>, <Publisher: O'Reilly>]
 >>> Publisher.objects.order_by("-name")        #逆向排序，在前面加一个减号 - 前缀。
[<Publisher: O'Reilly>, <Publisher: Apress>]
添加默认排序，可以使用class Meta，参见books/models.py中的Publisher类中的class Meta

连锁查询：
>>> Publisher.objects.filter(country="U.S.A.").order_by("-name")
[<Publisher: O'Reilly>, <Publisher: Apress>]

限制返回的数据：
>>> Publisher.objects.order_by('name')[0]       #等于mysql中的LIMIT 1
<Publisher: Apress>
>>> Publisher.objects.order_by('name')[0:2]     #相当于python的切片显示
注意，不支持Python的负索引，如Publisher.objects.order_by('name')[-1]。但可以通过下面方式从尾部取数据blisher.objects.order_by('-name')[0]

更新指定对象值：
上述的方法
>>> p = Publisher.objects.get(name='Apress')
>>> p.name = 'Apress Publishing'
>>> p.save()
相当于
SELECT id, name, address, city, state_province, country, website
FROM books_publisher
WHERE name = 'Apress';

UPDATE books_publisher SET
    name = 'Apress Publishing',
    address = '2855 Telegraph Ave.',
    city = 'Berkeley',
    state_province = 'CA',
    country = 'U.S.A.',
    website = 'http://www.apress.com'
WHERE id = 52;
即会更新所有数据，如果此数据中的列正被其他进程修改，则造成影响。
正确且高效的方法是使用update()。相当于MYSQL的
UPDATE books_publisher
SET name = 'Apress Publishing'
WHERE id = 52;
>>> Publisher.objects.filter(id=52).update(name='Apress Publishing')        #更新条件限定的一条数据
>>> Publisher.objects.all().update(country='USA')       #更新所有数据
2       #返回值为受影响的条目。

删除对象：
>>> p = Publisher.objects.get(name="O'Reilly")
>>> p.delete()
>>> Publisher.objects.all()
[<Publisher: Apress Publishing>]
同样我们可以在结果集上调用delete()方法同时删除多条记录。
>>> Publisher.objects.filter(country='USA').delete()
>>> Publisher.objects.all().delete()        #删除所有数据
>>> Publisher.objects.all()
[]


【【web管理界面】】
首先确认settings中INSTALLED_APPS和MIDDLEWARE中相关contrib插件没有被删改。
创建超级账户。运行
python manage.py makemigrations
python manage.py createsuperuser
启动服务器。

【修改语言】：
在settings中的MIDDLEWARE字典中加入'django.middleware.locale.LocaleMiddleware'

【将你的Models加入到Admin管理中】
编辑app下的admin.py,添加
from books.models import Publisher, Book, Author

admin.site.register(Publisher)
admin.site.register(Book)
admin.site.register(Author)

【设置字段可选】
books/models.py文件里,class Author(models.Model):中email = models.EmailField(blank=True)。这些代码告诉Django，作者的邮箱地址允许输入一个空值。 所有字段都默认blank=False，这使得它们不允许输入空值。

【设置日期型和数字型字段可选】
日期型、时间型和数字型字段不接受空字符串。在Django模块中，你可以通过添加null=True来指定一个字段允许为NULL。如果你想允许一个日期型或数字型字段为空，你需要使用null=True  和 blank=True。
class Book(models.Model):
    title = models.CharField(max_length=100)
    authors = models.ManyToManyField(Author)
    publisher = models.ForeignKey(Publisher)
    publication_date = models.DateField(blank=True, null=True)
上述代码的null=True。
此操作需要重新生成数据库。

【自定义字段标签】
在编辑页面中，每个字段的标签都是从模块的字段名称生成的。 规则很简单： 用空格替换下划线；首字母大写。例如：Book模块中publication_date的标签是Publication date。
自定义标签名方法：email = models.EmailField(blank=True, verbose_name='e-mail' )

【自定义ModelAdmin类】
在models.py中添加class AuthorAdmin(admin.ModelAdmin):
    list_display = ('first_name', 'last_name', 'email')，修改admin.site.register(Author, AuthorAdmin)后，刷新浏览器，会在Author标签页中看到出现了设置的标签列，页面顶端看到一个查询栏。
search_fields = ('first_name', 'last_name'),添加搜索框
list_filter = ('publication_date', )，页面右侧添加过滤器，为日期型字段提供了快捷过滤方式，它包含：今天、过往七天、当月和今年。
`` 过滤器`` 同样适用于其它类型的字段，而不单是`` 日期型`` （请在`` 布尔型`` 和`` 外键`` 字段上试试）。当有两个以上值时，过滤器就会显示。
date_hierarchy = 'publication_date',date_hierarchy接受的是* 字符串* ，而不是元组。因为只能对一个日期型字段进行层次划分。页面中的列表顶端会有一个逐层深入的导航条，效果如图 6-11. 它从可用的年份开始，然后逐层细分到月乃至日。
ordering = ('-publication_date', ),以publication_date倒序显示

【自定义编辑表单】
在admin.py中的类中修改
fields = ('title', 'authors', 'publisher', 'publication_date')，编辑表单将按照指定的顺序显示各字段。
fields = ('title', 'authors', 'publisher')，隐藏了'publication_date'，可以排除一些不想被其他人编辑的fields。在编辑页面就无法对publication date进行改动。
filter_horizontal = ('authors',),对‘多对多选项’优化，当选项过多时，方便选中所需项。只能用在多对多字段 上, 而不能用于 ForeignKey字段。（filter_vertical用处类似，为竖排展现外观）
raw_id_fields = ('publisher',),修改外键默认的下拉框展现方式，如数据过多，加载下拉框时间过长，使用该参数可以改为文本框，输入键值ID即可。

【用户、用户组和权限】
界面上配置


##表单##
介绍对用户通过表单提交的数据进行访问、有效性检查以及其它处理

【从Request对象中获取数据】
HttpRequest对象包含当前请求URL的一些信息：
属性/方法 	说明 	举例
request.path 	除域名以外的请求路径，以正斜杠开头 	"/hello/"
request.get_host() 	主机名（比如，通常所说的域名） 	"127.0.0.1:8000" or "www.example.com"
request.get_full_path() 	请求路径，可能包含查询字符串 	"/hello/?print=true"
request.is_secure() 	如果通过HTTPS访问，则此方法返回True， 否则返回False 	True 或者 False

在view函数里，要始终用这个属性或方法来得到URL，而不要手动输入：
# BAD!
def current_url_view_bad(request):
    return HttpResponse("Welcome to the page at /current/")

# GOOD
def current_url_view_good(request):
    return HttpResponse("Welcome to the page at %s" % request.path)

request.META 是一个Python字典，包含了所有本次HTTP请求的Header信息，比如用户IP地址和用户Agent（通常是浏览器的名称和版本号）。即基本的元数据。 注意，Header信息的完整列表取决于用户所发送的Header信息和服务器端设置的Header信息。 这个字典中几个常见的键值有：
    HTTP_REFERER，进站前链接网页，如果有的话。 （请注意，它是REFERRER的笔误。）
    HTTP_USER_AGENT，用户浏览器的user-agent字符串，如果有的话。 例如： "Mozilla/5.0 (X11; U; Linux i686; fr-FR; rv:1.8.1.17) Gecko/20080829 Firefox/2.0.0.17" .
    REMOTE_ADDR 客户端IP，如："12.345.67.89" 。(如果申请是经过代理服务器的话，那么它可能是以逗号分割的多个IP地址，如："12.345.67.89,23.456.78.90" 。

因为 request.META 是一个普通的Python字典，因此当你试图访问一个不存在的键时，会触发一个KeyError异常。
# BAD!
def ua_display_bad(request):
    ua = request.META['HTTP_USER_AGENT']  # Might raise KeyError!
    return HttpResponse("Your browser is %s" % ua)

# GOOD (VERSION 1)
def ua_display_good1(request):
    try:
        ua = request.META['HTTP_USER_AGENT']
    except KeyError:
        ua = 'unknown'
    return HttpResponse("Your browser is %s" % ua)

# GOOD (VERSION 2)
def ua_display_good2(request):
    ua = request.META.get('HTTP_USER_AGENT', 'unknown')
    return HttpResponse("Your browser is %s" % ua)

request.META返回的所有数据，可见Django/views.py下的def display_meta(request)即相关urls.py中添加的对应url

【提交的数据信息】
“request.GET和request.POST是类字典对象”,request.GET和request.POST都有get()、keys()和values()方法，也拥有一些普通的字典对象所没有的方法。
POST数据是来自HTML中的〈form〉标签提交的，而GET数据可能来自〈form〉提交也可能是URL中的查询字符串(the query string)。
确认request.method的值是’POST’。用户浏览表单时这个值并不存在，当且仅当表单被提交时这个值才出现。

【简单的例子】
books/views.py中search_form和search方法，templates中的search_form.html模板，制作了一个search框功能。

【POST与GET之间有什么不同？】
当我们提交表单仅仅需要获取数据时就可以用GET； 而当我们提交表单时需要更改服务器数据的状态，或者说发送e-mail，或者其他不仅仅是获取并显示数据的时候就使用POST。 在这个搜索书籍的例子里，我们使用GET，因为这个查询不会更改服务器数据的状态。

【验证功能的表单】
见contact/例子

【Form类】
Django带有一个form库，称为django.forms，这个库可以处理我们本章所提到的包括HTML表单显示以及验证。
##用法介绍##
from contact.forms import ContactForm   #已手动编辑的文件和类
f = ContactForm()
print(f)
<tr><th><label for="id_subject">Subject:</label></th><td><input type="text" name="subject" required id="id_subject" /></td></tr>
<tr><th><label for="id_email">Email:</label></th><td><input type="email" name="email" id="id_email" /></td></tr>
<tr><th><label for="id_message">Message:</label></th><td><input type="text" name="message" required id="id_message" /></td></tr>

##显示个别字段
print(f['subject'])
    out:<input type="text" name="subject" required id="id_subject" />

##校验数据
f = ContactForm({'subject': 'Hello', 'email': 'adrian@example.com', 'message': 'Nice site!'})   #创建一个新的对Form象，并且传入一个与定义匹配的字典类型数据

f.is_bound
    Out[8]: True

f.is_valid()    #调用任何绑定form的is_valid()方法，就可以知道它的数据是否合法。如字段属性为required=False，则即使该字段为空也合法。
    out:True

f['message'].errors：    #查看每个字段的出错消息，如[u'This field is required.']
    out:[u'xxxxx']

f = ContactForm({'subject': 'Hello', 'message': ''})    #每一个邦定Form实体都有一个errors属性，它为你提供了一个字段与错误消息相映射的字典表。
f.errors
    out:{'message': [u'This field is required.']}

如果一个Form实体的数据是合法的，它就会有一个可用的cleaned_data属性。 这是一个包含干净的提交数据的字典。 Django的form框架不但校验数据，它还会把它们转换成相应的Python类型数据，这叫做清理数据。
f = ContactForm({subject': Hello, email: adrian@example.com, message: Nice site!})
f.is_valid()
    out:True
f.cleaned_data
    out:{message': uNice site!, email: uadrian@example.com, subject: uHello}
contact form只涉及字符串类型，它们会被清理成Unicode对象。如果我们使用整数型或日期型，form框架会确保方法使用合适的Python整数型或datetime.date型对象。

##在视图中使用Form对象
见contact/views.py和templates/contact_form_new.html

##改变字段显示
contact/forms.py中messge中的参数。
forms框架把每一个字段的显示逻辑分离到一组部件（widget）中。 每一个字段类型都拥有一个默认的部件，我们也可以容易地替换掉默认的部件，或者提供一个自定义的部件。

##设置最大长度
contact/forms.py中messge中的参数。
subject = forms.CharField(max_length=100)
使subject限制在100个字符以内。 为此，仅需为CharField提供max_length参数.
选项min_length参数同样可用。

##设置初始值
contact/views.py中form = ContactForm(initial={'subject': 'i love web'})参数。
请注意，传入* 初始值* 数据和传入数据以* 绑定* 表单是有区别的。 最大的区别是，如果仅传入* 初始值* 数据，表单是unbound的，那意味着它没有错误消息。

##自定义校验规则
见contact/forms.py中的方法。
form系统自动寻找匹配的函数方法，该方法名称以clean_开头，并以字段名称结束。 如果有这样的方法，它将在校验时被调用。
clean_message()方法将在指定字段的默认校验逻辑执行* 之后* 被调用。（本例中，在必填CharField这个校验逻辑之后。）因为字段数据已经被部分处理，所以它被从self.cleaned_data中提取出来了。同样，我们不必担心数据是否为空，因为它已经被校验过了。

##CSRF token missing or incorrect
views.py中添加
from django.template import RequestContext
...
return render(request, param1, param2)
contact_form_new.html中添加
<form action="" method="post">
    {% csrf_token %}    #<form>标签后添加{% csrf_token %}
具体见例子contact/views.py,templates/contact_form_new.html

##指定标签
contact/forms.py中email = forms.EmailField(required=False, label='Your email address')
可以自定义字段的标签。 仅需使用label

##定制Form设计
修改form的显示的最快捷的方式是使用CSS。
虽然，自动生成HTML是很方便的，但是在某些时候，你会想覆盖默认的显示。 {{form.as_table}}和其它的方法在开发的时候是一个快捷的方式，form的显示方式也可以在form中被方便地重写。
每一个字段部件(<input type=”text”>, <select>, <textarea>, 或者类似)都可以通过访问{{form.字段名}}进行单独的渲染。
<html>
<head>
    <title>Contact us</title>
</head>
<body>
    <h1>Contact us</h1>

    {% if form.errors %}
        <p style="color: red;">
            Please correct the error{{ form.errors|pluralize }} below.
        </p>
    {% endif %}

    <form action="" method="post">
        <div class="field">
            {{ form.subject.errors }}
            <label for="id_subject">Subject:</label>
            {{ form.subject }}
        </div>
        <div class="field">
            {{ form.email.errors }}
            <label for="id_email">Your e-mail address:</label>
            {{ form.email }}
        </div>
        <div class="field">
            {{ form.message.errors }}
            <label for="id_message">Message:</label>
            {{ form.message }}
        </div>
        <input type="submit" value="Submit">
    </form>
</body>
</html>
{{ form.message.errors }} 会在 <ul class="errorlist"> 里面显示，如果字段是合法的，或者form没有被绑定，就显示一个空字符串。 我们还可以把 form.message.errors 当作一个布尔值或者当它是list在上面做迭代， 例如：

<div class="field{% if form.message.errors %} errors{% endif %}">
    {% if form.message.errors %}
        <ul>
        {% for error in form.message.errors %}
            <li><strong>{{ error }}</strong></li>
        {% endfor %}
        </ul>
    {% endif %}
    <label for="id_message">Message:</label>
    {{ form.message }}
</div>


##高级视图和URL配置##

【URLconf 技巧】
1.10以上版本取消了字符串表示url的功能。

##使用命名组
命名的正则表达式组的语法是 (?P<name>pattern) ，这里 name 是组的名字，而 pattern 是匹配的某个模式。
使用无名组的 URLconf 的例子:
from django.conf.urls.defaults import *
from mysite import views

urlpatterns = patterns('',
    (r'^articles/(\d{4})/$', views.year_archive),
    (r'^articles/(\d{4})/(\d{2})/$', views.month_archive),
)
下面是相同的 URLconf，使用命名组进行了重写:
from django.conf.urls.defaults import *
from mysite import views

urlpatterns = patterns('',
    (r'^articles/(?P<year>\d{4})/$', views.year_archive),
    (r'^articles/(?P<year>\d{4})/(?P<month>\d{2})/$', views.month_archive),
)

差别： 取的值是以关键字参数的方式而不是以位置参数的方式传递给视图函数的。
例如，如果不带命名组，请求 /articles/2006/03/ 将会等同于这样的函数调用：
month_archive(request, '2006', '03')
而带命名组，同样的请求就会变成这样的函数调用：
month_archive(request, year='2006', month='03')

注意：如果在URLconf中使用命名组，那么命名组和非命名组是不能同时存在于同一个URLconf的模式中的。 如果你这样做，Django不会抛出任何错误，但你可能会发现你的URL并没有像你预想的那样匹配正确。

##传递额外的参数到视图函数中
比如说，你有两个视图，它们的内容是一致的，除了它们所用的模板不太一样。
# urls.py

from django.conf.urls.defaults import *
from mysite import views

urlpatterns = patterns('',
    (r'^foo/$', views.foobar_view, {'template_name': 'template1.html'}),
    (r'^bar/$', views.foobar_view, {'template_name': 'template2.html'}),
)

# views.py

from django.shortcuts import render_to_response
from mysite.models import MyModel

def foobar_view(request, template_name):
    m_list = MyModel.objects.filter(is_new=True)
    return render_to_response(template_name, {'m_list': m_list})

URLconf指定了 template_name ，而视图函数会把它当成另一个参数。

##伪造捕捉到的URLconf值
urlpatterns = patterns('',
    (r'^mydata/(?P<month>\w{3})/(?P<day>\d\d)/$', views.my_view),
)
然后视图函数的原型看起来会是：
def my_view(request, month, day):
    # ....
比如你可能会想增加这样一个URL， /mydata/birthday/ ， 这个URL等价于 /mydata/jan/06/ 。这时你可以这样利用额外URLconf参数：
urlpatterns = patterns('',
    (r'^mydata/birthday/$', views.my_view, {'month': 'jan', 'day': '06'}),
    (r'^mydata/(?P<month>\w{3})/(?P<day>\d\d)/$', views.my_view),
)
不用改变你的视图函数。 视图函数只会关心它 获得 了 参数，它不会去管这些参数到底是捕捉回来的还是被额外提供的。

##创建一个通用视图
以开始创作高抽象的视图。 更具体地说，比如这个视图显示一系列的 Event 对象，那个视图显示一系列的 BlogEntry 对象，并意识到它们都是一个用来显示一系列对象的视图的特例，而对象的类型其实就是一个变量。
以这段代码作为例子：

# urls.py

from django.conf.urls.defaults import *
from mysite import views

urlpatterns = patterns('',
    (r'^events/$', views.event_list),
    (r'^blog/entries/$', views.entry_list),
)

# views.py

from django.shortcuts import render_to_response
from mysite.models import Event, BlogEntry

def event_list(request):
    obj_list = Event.objects.all()
    return render_to_response('mysite/event_list.html', {'event_list': obj_list})

def entry_list(request):
    obj_list = BlogEntry.objects.all()
    return render_to_response('mysite/blogentry_list.html', {'entry_list': obj_list})

这两个视图做的事情实质上是一样的： 显示一系列的对象。 让我们把它们显示的对象的类型抽象出来：

# urls.py

from django.conf.urls.defaults import *
from mysite import models, views

urlpatterns = patterns('',
    (r'^events/$', views.object_list, {'model': models.Event}),
    (r'^blog/entries/$', views.object_list, {'model': models.BlogEntry}),
)

# views.py

from django.shortcuts import render_to_response

def object_list(request, model):
    obj_list = model.objects.all()
    template_name = 'mysite/%s_list.html' % model.__name__.lower()
    return render_to_response(template_name, {'object_list': obj_list})

我们通过 model 参数直接传递了模型类。 额外URLconf参数的字典是可以传递任何类型的对象，而不仅仅只是字符串。
我们使用 model.__name__.lower() 来决定模板的名字。 每个Python的类都有一个 __name__ 属性返回类名。 这特性在当我们直到运行时刻才知道对象类型的这种情况下很有用。 比如， BlogEntry 类的 __name__ 就是字符串 'BlogEntry' 。

##提供视图配置选项
一个应用中比较常见的可供配置代码是模板名字：

def my_view(request, template_name):
    var = do_something()
    return render_to_response(template_name, {'var': var})

##使用缺省视图参数
# urls.py

from django.conf.urls.defaults import *
from mysite import views

urlpatterns = patterns('',
    (r'^blog/$', views.page),
    (r'^blog/page(?P<num>\d+)/$', views.page),
)

# views.py

def page(request, num='1'):
    # Output the appropriate page of blog entries, according to num.
在这里，两个URL表达式都指向了同一个视图 views.page ，但是第一个表达式没有传递任何参数。 如果匹配到了第一个样式， page() 函数将会对参数 num 使用默认值 "1" ，如果第二个表达式匹配成功， page() 函数将使用正则表达式传递过来的num的值。

##特殊情况下的视图
利用URLconf从顶向下的解析顺序这个特点：
urlpatterns = patterns('',
    # ...
    ('^auth/user/add/$', views.user_add_stage),
    ('^([^/]+)/([^/]+)/add/$', views.add_stage),
    # ...
)
象 /auth/user/add/ 的请求将会被 user_add_stage 视图处理。 尽管URL也匹配第二种模式，它会先匹配上面的模式。

##包含其他URLconf
urlpatterns = patterns('',
    (r'^weblog/', include('mysite.blog.urls')),
    (r'^photos/', include('mysite.photos.urls')),
    (r'^about/$', 'mysite.views.about'),
)
这里就是被包含的URLconf mysite.blog.urls ：
from django.conf.urls.defaults import *

urlpatterns = patterns('',
    (r'^(\d\d\d\d)/$', 'mysite.blog.views.year_detail'),
    (r'^(\d\d\d\d)/(\d\d)/$', 'mysite.blog.views.month_detail'),
)

/weblog/2007/ ：在第一个URLconf中，模式 r'^weblog/' 被匹配。 因为它是一个 include() ，Django将截掉所有匹配的文本，在这里是 'weblog/' 。URL剩余的部分是 2007/ ， 将在 mysite.blog.urls 这个URLconf的第一行中被匹配到。 URL仍存在的部分为 2007/ ,与第一行的 mysite.blog.urlsURL设置相匹配。
/weblog//2007/(包含两个斜杠) 在第一个URLconf中,r’^weblog/’匹配 因为它有一个include(),django去掉了匹配的部,在这个例子中匹配的部分是’weblog/’ 剩下的部分是/2007/ (最前面有一个斜杠),不匹配mysite.blog.urls中的任何一行.
/about/ : 这个匹配第一个URLconf中的 mysite.views.about 视图

##捕获的参数如何和include()协同工作
一个被包含的URLconf接收任何来自parent URLconfs的被捕获的参数，比如:

# root urls.py

from django.conf.urls.defaults import *

urlpatterns = patterns('',
    (r'^(?P<username>\w+)/blog/', include('foo.urls.blog')),
)

# foo/urls/blog.py

from django.conf.urls.defaults import *

urlpatterns = patterns('',
    (r'^$', 'foo.views.blog_index'),
    (r'^archive/$', 'foo.views.blog_archive'),
)
这个被捕获的参数 总是 传递到被包含的URLconf中的 每一 行，不管那些行对应的视图是否需要这些参数。


##模板高级进阶##
模板 渲染 就是是通过从context获取值来替换模板中变量并执行所有的模板标签。

【Context处理器】
待补充。

【html自动转意】
在django里默认情况下，每一个模板自动转意每一个变量标签的输出。

##关闭方法：
对于单独的变量，用safe过滤器为单独的变量关闭自动转意。
This will not be escaped: {{ data|safe }}

对于模板块，,用标签autoescape来包装整个模板(或者模板中常用的部分)。
{% autoescape off %}
    Hello {{ name }}
{% endautoescape %}
autoescape 标签有两个参数on和off 有时,你可能想阻止一部分自动转意,对另一部分自动转意。
Auto-escaping is on by default. Hello {{ name }}

{% autoescape off %}
    This will not be auto-escaped: {{ data }}.

    Nor this: {{ other_data }}
    {% autoescape on %}
        Auto-escaping applies again: {{ name }}
    {% endautoescape %}
{% endautoescape %}

【创建一个模板库】
创建一个模板库分两步走：
第一，决定模板库应该放在哪个Django应用下。 如果你通过 manage.py startapp 创建了一个应用，你可以把它放在那里，或者你可以为模板库单独创建一个应用。 我们更推荐使用后者，因为你的filter可能在后来的工程中有用。
无论你采用何种方式，请确保把你的应用添加到 INSTALLED_APPS 中。 我们稍后会解释这一点。
第二，在适当的Django应用包里创建一个 templatetags 目录。 这个目录应当和 models.py 、 views.py 等处于同一层次。    例如：
books/
    __init__.py
    models.py
    templatetags/
    views.py

    在 templatetags 中创建两个空文件： 一个 __init__.py （告诉Python这是 一个包含了Python代码的包）和一个用来存放你自定义的标签/过滤器定义的文件。 第二个文件的名字稍后将用来加载标签。 例如，如果你的自定义标签/过滤器在一个叫作 poll_extras.py 的文件中，你需要在模板中写入如下内容：
{% load poll_extras %}

【自定义模板过滤器】
自定义过滤器就是有一个或两个参数的Python函数:
    (输入)变量的值
    参数的值， 可以是默认值或者完全留空
例如，在过滤器 {{ var|foo:"bar" }} 中 ，过滤器 foo 会被传入变量 var 和默认参数 bar。

下面是一个完整的模板库的例子，它包含一个 cut 过滤器：

from django import template

register = template.Library()

@register.filter(name='cut')
def cut(value, arg):
    return value.replace(arg, '')

【自定义模板标签】
例如，写一个显示当前日期的模板标签：{% current_time %}。在这个例子里，标签应该这样使用：
<p>The time is {% current_time "%Y-%m-%d %I:%M %p" %}.</p>
这个函数的分析器会获取参数并创建一个 Node 对象:
from django import template

register = template.Library()

def do_current_time(parser, token):
    try:
        # split_contents() knows not to split quoted strings.
        tag_name, format_string = token.split_contents()
    except ValueError:
        msg = '%r tag requires a single argument' % token.split_contents()[0]
        raise template.TemplateSyntaxError(msg)
    return CurrentTimeNode(format_string[1:-1])
这里需要说明的地方很多：
    每个标签编译函数有两个参数，parser和token。parser是模板解析器对象。 我们在这个例子中并不使用它。 token是正在被解析的语句。
    token.contents 是包含有标签原始内容的字符串。 在我们的例子中，它是 'current_time "%Y-%m-%d %I:%M %p"' 。
    token.split_contents() 方法按空格拆分参数同时保证引号中的字符串不拆分。 应该避免使用 token.contents.split() （仅使用Python的标准字符串拆分）。 它不够健壮，因为它只是简单的按照所有空格进行拆分，包括那些引号引起来的字符串中的空格。
    这个函数可以抛出 django.template.TemplateSyntaxError ，这个异常提供所有语法错误的有用信息。
    不要把标签名称硬编码在你的错误信息中，因为这样会把标签名称和你的函数耦合在一起。 token.split_contents()[0]总是记录标签的名字，就算标签没有任何参数。
    这个函数返回一个 CurrentTimeNode （稍后我们将创建它），它包含了节点需要知道的关于这个标签的全部信息。 在这个例子中，它只是传递了参数 "%Y-%m-%d %I:%M %p" 。模板标签开头和结尾的引号使用 format_string[1:-1] 除去。
    模板标签编译函数 必须 返回一个 Node 子类，返回其它值都是错的。

【编写模板节点】
编写自定义标签的第二步就是定义一个拥有 render() 方法的 Node 子类。 继续前面的例子，我们需要定义 CurrentTimeNode ：
import datetime

class CurrentTimeNode(template.Node):
    def __init__(self, format_string):
        self.format_string = str(format_string)

    def render(self, context):
        now = datetime.datetime.now()
        return now.strftime(self.format_string)

【注册标签】
最后，你需要用你模块的Library 实例注册这个标签。 注册自定义标签与注册自定义过滤器非常类似（如前文所述）。 只需实例化一个 template.Library 实例然后调用它的 tag() 方法。 例如：

register.tag('current_time', do_current_time)

tag() 方法需要两个参数:
    模板标签的名字（字符串）。
    编译函数。

也可以使用 register.tag装饰器：

@register.tag(name="current_time")
def do_current_time(parser, token):
    # ...

@register.tag
def shout(parser, token):
    # ...

如果你像在第二个例子中那样忽略 name 参数的话，Django会使用函数名称作为标签名称。

【在上下文中设置变量】
由模板标签来指定需要设定的变量的名称，就像这样：

{% get_current_time "%Y-%M-%d %I:%M %p" as my_current_time %}
<p>The current time is {{ my_current_time }}.</p>

为此，你需要重构编译函数和 Node 类，如下所示：

import re

class CurrentTimeNode3(template.Node):
    def __init__(self, format_string, var_name):
        self.format_string = str(format_string)
        self.var_name = var_name

    def render(self, context):
        now = datetime.datetime.now()
        context[self.var_name] = now.strftime(self.format_string)
        return ''

def do_current_time(parser, token):
    # This version uses a regular expression to parse tag contents.
    try:
        # Splitting by None == splitting by spaces.
        tag_name, arg = token.contents.split(None, 1)
    except ValueError:
        msg = '%r tag requires arguments' % token.contents[0]
        raise template.TemplateSyntaxError(msg)

    m = re.search(r'(.*?) as (\w+)', arg)
    if m:
        fmt, var_name = m.groups()
    else:
        msg = '%r tag had invalid arguments' % tag_name
        raise template.TemplateSyntaxError(msg)

    if not (fmt[0] == fmt[-1] and fmt[0] in ('"', "'")):
        msg = "%r tag's argument should be in quotes" % tag_name
        raise template.TemplateSyntaxError(msg)

    return CurrentTimeNode3(fmt[1:-1], var_name)

【分析直至另一个模板标签】
模板标签可以像包含其它标签的块一样工作（想想 {% if %} 、 {% for %} 等）。 要创建一个这样的模板标签，在你的编译函数中使用 parser.parse() 。

【分析直至另外一个模板标签并保存内容】
在前一个例子中， do_comment() 抛弃了{% comment %} 和 {% endcomment %} 之间的所有内容。当然也可以修改和利用下标签之间的这些内容。

【简单标签的快捷方式】
许多模板标签接收单一的字符串参数或者一个模板变量引用，然后独立地根据输入变量和一些其它外部信息进行处理并返回一个字符串。 例如，我们先前写的current_time标签就是这样一个例子。 我们给定了一个格式化字符串，然后它返回一个字符串形式的时间。

为了简化这类标签，Django提供了一个帮助函数simple_tag。这个函数是django.template.Library的一个方法，它接受一个只有一个参数的函数作参数，把它包装在render函数和之前提及过的其他的必要单位中，然后通过模板系统注册标签。

【包含标签】
另外一类常用的模板标签是通过渲染 其他 模板显示数据的。 比如说，Django的后台管理界面，它使用了自定义的模板标签来显示新增/编辑表单页面下部的按钮。 那些按钮看起来总是一样的，但是链接却随着所编辑的对象的不同而改变。 这就是一个使用小模板很好的例子，这些小模板就是当前对象的详细信息。

【编写自定义模板加载器】
Djangos 内置的模板加载器（在先前的模板加载内幕章节有叙述）通常会满足你的所有的模板加载需求，但是如果你有特殊的加载需求的话，编写自己的模板加载器也会相当简单。 比如：你可以从数据库中，或者利用Python的绑定直接从Subversion库中，更或者从一个ZIP文档中加载模板。


##数据模型高级进阶##

【访问外键(Foreign Key)值】
当你获取一个ForeignKey 字段时,你会得到相关的数据模型对象。 例如：
>>> b = Book.objects.get(id=50)
>>> b.publisher
<Publisher: Apress Publishing>
>>> b.publisher.website
u'http://www.apress.com/'

对于用`` ForeignKey`` 来定义的关系来说，在关系的另一端也能反向的追溯回来，只不过由于不对称性的关系而稍有不同。 通过一个`` publisher`` 对象，直接获取 books ，用 publisher.book_set.all() ，如下：
>>> p = Publisher.objects.get(name='Apress Publishing')
>>> p.book_set.all()
[<Book: The Django Book>, <Book: Dive Into Python>, ...]

【访问多对多值(Many-to-Many Values)】
多对多和外键工作方式相同，只不过我们处理的是QuerySet而不是模型实例。 例如,这里是如何查看书籍的作者：

>>> b = Book.objects.get(id=50)
>>> b.authors.all()
[<Author: Adrian Holovaty>, <Author: Jacob Kaplan-Moss>]
>>> b.authors.filter(first_name='Adrian')
[<Author: Adrian Holovaty>]
>>> b.authors.filter(first_name='Adam')
[]

反向查询也可以。 要查看一个作者的所有书籍,使用author.book_set ,就如这样:
>>> a = Author.objects.get(first_name='Adrian', last_name='Holovaty')
>>> a.book_set.all()
[<Book: The Django Book>, <Book: Adrian's Other Book>]

这里,就像使用 ForeignKey字段一样，属性名book_set是在数据模型(model)名后追加_set。

【更改数据库模式(Database Schema)】
如果你新增或修改数据模型里的字段,或是删除了一个数据模型，你需要手动在数据库里进行相应的修改。 这段将解释了具体怎么做。

添加字段：
当要向一个产品设置表(或者说是model)添加一个字段的时候，要使用的技巧是利用Django不关心表里是否包含model里所没有的列的特性。 策略就是现在数据库里加入字段，然后同步Django的模型以包含新字段。
首先，进入开发环境(也就是说，不是在发布环境里)：
    在你的模型里添加字段。
    运行 manage.py sqlall [yourapp] 来测试模型新的 CREATE TABLE 语句。 注意为新字段的列定义。
    开启你的数据库的交互命令界面(比如, psql 或mysql , 或者可以使用 manage.py dbshell )。 执行 ALTER TABLE 语句来添加新列。
    使用Python的manage.py shell，通过导入模型和选中表单(例如， MyModel.objects.all()[:5] )来验证新的字段是否被正确的添加 ,如果一切顺利,所有的语句都不会报错。
然后在你的产品服务器上再实施一遍这些步骤。
    启动数据库的交互界面。
    执行在开发环境步骤中，第三步的ALTER TABLE语句。
    将新的字段加入到模型中。 如果你使用了某种版本控制工具，并且在第一步中，已经提交了你在开发环境上的修改，现在，可以在生产环境中更新你的代码了（例如，如果你使用Subversion，执行svn update。
    重新启动Web server，使修改生效。

删除字段：
步骤：删除字段，然后重新启动你的web服务器。
ALTER TABLE books_book DROP COLUMN num_pages;

删除多对多关联字段：
从你的模型中删除ManyToManyField，然后重启web服务器。
DROP TABLE books_book_authors;

删除模型：
从文件中删除你想要删除的模型，然后重启web 服务器models.py
DROP TABLE books_book;

【Managers】
模块manager是一个对象，Django模块通过它进行数据库查询。
增加额外的manager方法是为模块添加表级功能的首选办法。
例如,我们为Book模型定义了一个title_count()方法，它需要一个关键字，返回包含这个关键字的书的数量。
class BookManager(models.Manager):
    def title_count(self, keyword):
        return self.filter(title__icontains=keyword).count()

>>> Book.objects.title_count('django')
4

【修改初始Manager QuerySets】
manager的基本QuerySet返回系统中的所有对象。 例如,`` Book.objects.all()`` 返回数据库book中的所有书本。
我们可以通过覆盖Manager.get_query_set()方法来重写manager的基本QuerySet。 get_query_set()按照你的要求返回一个QuerySet。

【模型方法】
为了给你的对像添加一个行级功能，那就定义一个自定义方法。 有鉴于manager经常被用来用一些整表操作（table-wide），模型方法应该只对特殊模型实例起作用。
这个模型有一些自定义方法：

from django.contrib.localflavor.us.models import USStateField
from django.db import models

class Person(models.Model):
    first_name = models.CharField(max_length=50)
    last_name = models.CharField(max_length=50)
    birth_date = models.DateField()
    address = models.CharField(max_length=100)
    city = models.CharField(max_length=50)
    state = USStateField() # Yes, this is U.S.-centric...

    def baby_boomer_status(self):
        "Returns the person's baby-boomer status."
        import datetime
        if datetime.date(1945, 8, 1) <= self.birth_date <= datetime.date(1964, 12, 31):
            return "Baby boomer"
        if self.birth_date < datetime.date(1945, 8, 1):
            return "Pre-boomer"
        return "Post-boomer"

    def is_midwestern(self):
        "Returns True if this person is from the Midwest."
        return self.state in ('IL', 'WI', 'MI', 'IN', 'OH', 'IA', 'MO')

    def _get_full_name(self):
        "Returns the person's full name."
        return u'%s %s' % (self.first_name, self.last_name)
    full_name = property(_get_full_name)

这是用法的实例：
>>> p = Person.objects.get(first_name='Barack', last_name='Obama')
>>> p.birth_date
datetime.date(1961, 8, 4)
>>> p.baby_boomer_status()
'Baby boomer'
>>> p.is_midwestern()
True
>>> p.full_name  # Note this isn't a method -- it's treated as an attribute
u'Barack Obama'

【执行原始SQL查询】
有时候你会发现Django数据库API带给你的也只有这么多，那你可以为你的数据库写一些自定义SQL查询。
不要把你的视图代码和django.db.connection语句混杂在一起，把它们放在自定义模型或者自定义manager方法中是个不错的主意。 比如，上面的例子可以被整合成一个自定义manager方法，就像这样：
from django.db import connection, models

class PersonManager(models.Manager):
    def first_names(self, last_name):
        cursor = connection.cursor()
        cursor.execute("""
            SELECT DISTINCT first_name
            FROM people_person
            WHERE last_name = %s""", [last_name])
        return [row[0] for row in cursor.fetchone()]

class Person(models.Model):
    first_name = models.CharField(max_length=50)
    last_name = models.CharField(max_length=50)
    objects = PersonManager()

然后这样使用:
>>> Person.objects.first_names('Lennon')
['John', 'Cynthia']


##通用视图##
Django内建通用视图可以实现如下功能：
    完成常用的简单任务： 重定向到另一个页面以及渲染一个指定的模板。
    显示列表和某个特定对象的详细内容页面。 第8章中提到的 event_list 和 entry_list 视图就是列表视图的一个例子。 一个单一的 event 页面就是我们所说的详细内容页面。
    呈现基于日期的数据的年/月/日归档页面，关联的详情页面，最新页面。 Django Weblogs (http://www.djangoproject.com/weblog/)的年、月、日的归档就是使用通用视图 架构的，就像是典型的新闻报纸归档。

【使用通用视图】
使用通用视图的方法是在URLconf文件中创建配置字典，然后把这些字典作为URLconf元组的第三个成员。 （对于这个技巧的应用可以参看第八章向视图传递额外选项。）
from django.conf.urls.defaults import *
from django.views.generic.simple import direct_to_template

urlpatterns = patterns('',
    (r'^about/$', direct_to_template, {
        'template': 'about.html'
    })
)

【对象的通用视图】
Django通用视图最有用的地方是呈现数据库中的数据。 因为这个应用实在太普遍了，Django带有很多内建的通用视图来帮助你很容易 地生成对象的列表和明细视图。

让我们先看看其中的一个通用视图： 对象列表视图。 我们使用第五章中的 Publisher 来举例：

class Publisher(models.Model):
    name = models.CharField(max_length=30)
    address = models.CharField(max_length=50)
    city = models.CharField(max_length=60)
    state_province = models.CharField(max_length=30)
    country = models.CharField(max_length=50)
    website = models.URLField()

    def __unicode__(self):
        return self.name

    class Meta:
        ordering = ['name']

要为所有的出版商创建一个列表页面，我们使用下面的URL配置：

from django.conf.urls.defaults import *
from django.views.generic import list_detail
from mysite.books.models import Publisher

publisher_info = {
    'queryset': Publisher.objects.all(),
}

urlpatterns = patterns('',
    (r'^publishers/$', list_detail.object_list, publisher_info)
)

这就是所要编写的所有Python代码。 当然，我们还需要编写一个模板。 我们可以通过在额外参数字典中包含一个template_name键来显式地告诉object_list视图使用哪个模板：

from django.conf.urls.defaults import *
from django.views.generic import list_detail
from mysite.books.models import Publisher

publisher_info = {
    'queryset': Publisher.objects.all(),
    **'template_name': 'publisher_list_page.html',**
}

urlpatterns = patterns('',
    (r'^publishers/$', list_detail.object_list, publisher_info)
)

在缺少template_name的情况下，object_list通用视图将自动使用一个对象名称。 在这个例子中，这个推导出的模板名称将是 "books/publisher_list.html" ，其中books部分是定义这个模型的app的名称， publisher部分是这个模型名称的小写。

这个模板将按照 context 中包含的变量 object_list 来渲染，这个变量包含所有的书籍对象。 一个非常简单的模板看起来象下面这样：

{% extends "base.html" %}

{% block content %}
    <h2>Publishers</h2>
    <ul>
        {% for publisher in object_list %}
            <li>{{ publisher.name }}</li>
        {% endfor %}
    </ul>
{% endblock %}

【扩展通用视图】

##制作友好的模板Context
你也许已经注意到范例中的出版商列表模板在变量 object_list 里保存所有的书籍。这个方法工作的很好，只是对编写模板的人不太友好。 他们必须知道这里正在处理的是书籍。 更好的变量名应该是publisher_list，这样变量所代表的内容就显而易见了。

我们可以很容易地像下面这样修改 template_object_name 参数的名称：

from django.conf.urls.defaults import *
from django.views.generic import list_detail
from mysite.books.models import Publisher

publisher_info = {
    'queryset': Publisher.objects.all(),
    'template_name': 'publisher_list_page.html',
    'template_object_name': 'publisher',
}

urlpatterns = patterns('',
    (r'^publishers/$', list_detail.object_list, publisher_info)
)

在模板中，通用视图会通过在template_object_name后追加一个_list的方式来创建一个表示列表项目的变量名。

##添加额外的Context
你常常需要呈现比通用视图提供的更多的额外信息。 例如，考虑一下在每个出版商的详细页面显示所有其他出版商列表。 object_detail 通用视图为context提供了出版商信息，但是看起来没有办法在模板中 获取 所有 出版商列表。

这是解决方法： 所有的通用视图都有一个额外的可选参数 extra_context 。这个参数是一个字典数据类型，包含要添加到模板的context中的额外的对象。 所以要给视图提供所有出版商的列表，我们就用这样的info字典：

publisher_info = {
    'queryset': Publisher.objects.all(),
    'template_object_name': 'publisher',
    **'extra_context': {'book_list': Book.objects.all()}**
}

这样就把一个 {{ book_list }} 变量放到模板的context中。 这个方法可以用来传递任意数据 到通用视图模板中去。

在 extra_context 中用一个回调（callback）来代替使用一个变量。 任何传递给extra_context的可调用对象（例如一个函数）都会在每次视图渲染前执行（而不是只执行一次）。 你可以象这样定义一个函数：

**def get_books():**
    **return Book.objects.all()**

publisher_info = {
    'queryset': Publisher.objects.all(),
    'template_object_name': 'publisher',
    'extra_context': **{'book_list': get_books}**
}

或者你可以使用另一个不是那么清晰但是很简短的方法，事实上 Publisher.objects.all 本身就是可以调用的：

publisher_info = {
    'queryset': Publisher.objects.all(),
    'template_object_name': 'publisher',
    'extra_context': **{'book_list': Book.objects.all}**
}

注意 Book.objects.all 后面没有括号；这表示这是一个函数的引用，并没有真正调用它（通用视图将会在渲染时调用它）。

##显示对象的子集
在让我们来仔细看看这个 queryset 。 大多数通用视图有一个queryset参数，这个参数告诉视图要显示对象的集合。
book_info = {
    'queryset': Book.objects.order_by('-publication_date'),
}

urlpatterns = patterns('',
    (r'^publishers/$', list_detail.object_list, publisher_info),
    **(r'^books/$', list_detail.object_list, book_info),**
)
是这并不是一个处理出版商相关书籍的最好方法。 如果我们想要添加另一个 出版商页面，我们就得在URL配置中写URL配置，如果有很多的出版商，这个方法就不能 接受了。 在接下来的章节我们将来解决这个问题。

##用函数包装来处理复杂的数据过滤
我们可以通过对 object_list 通用视图进行包装来避免 写一大堆的手工代码。

##处理额外工作
我们再来看看最后一个常用模式：

想象一下我们在 Author 对象里有一个 last_accessed 字段，我们用这个字段来记录最近一次对author的访问。 当然通用视图 object_detail 并不能处理这个问题，但是我们仍然可以很容易地编写一个自定义的视图来更新这个字段。

首先，我们需要在URL配置里设置指向到新的自定义视图：

from mysite.books.views import author_detail

urlpatterns = patterns('',
    # ...
    **(r'^authors/(?P<author_id>\d+)/$', author_detail),**
    # ...
)

接下来写包装函数：

import datetime
from django.shortcuts import get_object_or_404
from django.views.generic import list_detail
from mysite.books.models import Author

def author_detail(request, author_id):
    # Delegate to the generic view and get an HttpResponse.
    response = list_detail.object_detail(
        request,
        queryset = Author.objects.all(),
        object_id = author_id,
    )

    # Record the last accessed date. We do this *after* the call
    # to object_detail(), not before it, so that this won't be called
    # unless the Author actually exists. (If the author doesn't exist,
    # object_detail() will raise Http404, and we won't reach this point.)
    now = datetime.datetime.now()
    Author.objects.filter(id=author_id).update(last_accessed=now)

    return response

注意

除非你添加 last_accessed 字段到你的 Author 模型并创建 books/author_detail.html 模板，否则这段代码不能真正工作。
3

我们可以用同样的方法修改通用视图的返回值。 如果我们想要提供一个供下载用的 纯文本版本的author列表，我们可以用下面这个视图：

def author_list_plaintext(request):
    response = list_detail.object_list(
        request,
        queryset = Author.objects.all(),
        mimetype = 'text/plain',
        template_name = 'books/author_list.txt'
    )
    response["Content-Disposition"] = "attachment; filename=authors.txt"
    return response

这个方法之所以工作是因为通用视图返回的 HttpResponse 对象可以象一个字典 一样的设置HTTP的头部。 随便说一下，这个 Content-Disposition 的含义是 告诉浏览器下载并保存这个页面，而不是在浏览器中显示它。


##部署Django##

DEBUG=False

##实现一个500模板

类似的，如果`` DEBUG`` 设置为`` False`` ，Djang不再会显示它自带的应对未处理的Python异常的错误反馈页面。 作为代替，它会查找一个名为`` 500.html`` 的模板并且显示它。 像`` 404.html`` 一样，这个模板应该被放置在你的模板根目录下。

这里有一个关于500.html的比较棘手的问题。你永远不能确定`` 为什么``会显示这个模板，所以它不应该做任何需要连接数据库，或者依赖任何可能被破坏的基础构件的事情。 （例如：它不应该使用自定义模板标签。）如果它用到了模板继承，那么父模板也就不应该依赖可能被破坏的基础构件。 因此，最好的方法就是避免模板继承，并且用一些非常简单的东西。 这是一个`` 500.html`` 的例子，可以把它作为一个起点：
1

<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
<head>
    <title>Page unavailable</title>
</head>
<body>
    <h1>Page unavailable</h1>

    <p>Sorry, but the requested page is unavailable due to a
    server hiccup.</p>

    <p>Our engineers have been notified, so check back later.</p>
</body>
</html>

##设置错误警告
先，改变你的ADMINS设置用来引入你的E-mail地址，以及那些任何需要被注意的联系人的E-mail地址。 这个设置采用了类似于(姓名, Email)元组，像这样：

ADMINS = (
    ('John Lennon', 'jlennon@example.com'),
    ('Paul McCartney', 'pmacca@example.com'),
)


##设置连接中断警报
如果你安装有CommonMiddleware(比如，你的MIDDLEWARE_CLASSES设置包含了’django.middleware.common.CommonMiddleware’的情况下，默认就安装了CommonMiddleware),你就具有了设置这个选项的能力：有人在访问你的Django网站的一个非空的链接而导致一个404错误的发生和连接中断的情况，你将收到一封邮件. 如果你想激活这个特性，设置SEND_BROKEN_LINK_EMAILS 为True(默认为False),并设置你的MANAGERS为某个人或某些人的邮件地址，这些邮件地址将会收到报告连接中断错误的邮件. MANAGERS使用和ADMINS 同样的语法.例如:

MANAGERS = (
    ('George Harrison', 'gharrison@example.com'),
    ('Ringo Starr', 'ringo@example.com'),
)

【使用针对产品的不同的设置】
设定多个settings.py，方便使用。
通过下面三种方法的其中一种达到这个目的。
    设置成两个全面的，彼此独立的配置文件
    设置一个基本的配置文件（比如，为了开发)和第二个（为了产品)配置文件，第二个配置文件仅仅从基本的那个配置文件导入配置，并对需要定义的进行复写.
    使用一个单独的配置文件，此配置文件包含一个Python的逻辑判断根据上下文环境改变设置。

【DJANGO_SETTINGS_MODULE】
DJANGO_SETTINGS_MODULE指向你的配置文件。

【用Apache和mod_python来部署Django】
mod_python (http://www.djangoproject.com/r/mod_python/)是一个在Apache中嵌入Python的Apache插件，它在服务器启动时将Python代码加载到内存中。

##基本配置
首先要安装有可用的 mod_python 模块的 Apache。这通常意味着应该有一个 LoadModule 指令在 Apache 配置文件中。 它看起来就像是这样：
LoadModule python_module /usr/lib/apache2/modules/mod_python.so

 Then, edit your Apache configuration file and add a <Location> directive that ties a specific URL path to a specific Django installation. 例如：

<Location "/">
    SetHandler python-program
    PythonHandler django.core.handlers.modpython
    SetEnv DJANGO_SETTINGS_MODULE mysite.settings
    PythonDebug Off
</Location>

要确保把 DJANGO_SETTINGS_MODULE 中的 mysite.settings 项目换成与你的站点相应的内容。

。。。（文档未显示内容,一些命令设置）

Apache 可能不但会运行在你正常登录的环境中，也会运行在其它不同的用户环境中；也可能会有不同的文件路径或 sys.path。 你需要告诉 mod_python 如何去寻找你的项目及 Django 的位置。
PythonPath "['/path/to/project', '/path/to/django'] + sys.path"

你应该在成品服务器上设置 PythonDebug Off 。如果你使用 PythonDebug On 的话，在程序产生错误时，你的用户会看到难看的（并且是暴露的） Python 回溯信息。

【在同一个 Apache 的实例中运行多个 Django 程序】
只要像下面这样使用 VirtualHost 你可以实现：

NameVirtualHost *

<VirtualHost *>
    ServerName www.example.com
    # ...
    SetEnv DJANGO_SETTINGS_MODULE mysite.settings
</VirtualHost>

<VirtualHost *>
    ServerName www2.example.com
    # ...
    SetEnv DJANGO_SETTINGS_MODULE mysite.other_settings
</VirtualHost>

如果你需要在同一个 VirtualHost 中运行两个 Django 程序，你需要特别留意一下以 确保 mod_python 的代码缓存不被弄得乱七八糟。 使用 PythonInterpreter 指令来将不 同的 <Location> 指令分别解释：

<VirtualHost *>
    ServerName www.example.com
    # ...
    <Location "/something">
        SetEnv DJANGO_SETTINGS_MODULE mysite.settings
        PythonInterpreter mysite
    </Location>

    <Location "/otherthing">
        SetEnv DJANGO_SETTINGS_MODULE mysite.other_settings
        PythonInterpreter mysite_other
    </Location>
</VirtualHost>

【用 mod_python 运行一个开发服务器】
因为 mod_python 缓存预载入了 Python 的代码，当在 mod_python 上发布 Django 站点时，你每 改动了一次代码都要需要重启 Apache 一次。 这还真是件麻烦事，所以这有个办法来避免它： 只要 加入 MaxRequestsPerChild 1 到配置文件中强制 Apache 在每个请求时都重新载入所有的 代码。 但是不要在产品服务器上使用这个指令，这会撤销 Django 的特权。

如果你是一个用分散的 print 语句（我们就是这样）来调试的程序员，注意这 print 语 句在 mod_python 中是无效的；它不会像你希望的那样产生一个 Apache 日志。 如果你需要在 mod_python 中打印调试信息，可能需要用到 Python 标准日志包（Pythons standard logging package）。 更多的信息请参见

【使用FastCGI部署Django应用】
FastCGI也是驻留在内存里为客户请求返回动态信息,而且也免掉了像传统的CGI一样启动进程时候的时间花销。 但于mod_python不同之处是它并不是作为模块运行在web服务器同一进程内的，而是有自己的独立进程。

【运行你的 FastCGI 服务器】
web服务器有两种方式于FastCGI进程交互： 使用Unix domain socket(在win32里面是 命名管道 )或者使用TCP socket.具体使用哪一个，那就根据你的偏好而定了，但是TCP socket弄不好的话往往会发生一些权限上的问题。

开始你的服务器项目，首先进入你的项目目录下（你的 manage.py 文件所在之处），然后使用 manage.py runfcgi 命令：

./manage.py runfcgi [options]

想了解如何使用 runfcgi ，输入 manage.py runfcgi help 命令。

你可以指定 socket 或者同时指定 host 和 port 。当你要创建Web服务器时，你只需要将服务器指向当你在启动FastCGI服务器时确定的socket或者host/port。

范例：

    在TCP端口上运行一个线程服务器：
./manage.py runfcgi method=threaded host=127.0.0.1 port=3033

    在Unix socket上运行prefork服务器：
./manage.py runfcgi method=prefork socket=/home/user/mysite.sock pidfile=django.pid

    启动，但不作为后台进程（在调试时比较方便）：
./manage.py runfcgi daemonize=false socket=/tmp/mysite.sock

【停止FastCGI的行程】
kill

【在Apache中以FastCGI的方式使用Django】
在Apache和FastCGI上使用Django，你需要安装和配置Apache，并且安装mod_fastcgi。
当完成了安装，通过 httpd.conf （Apache的配置文件）来让Apache和Django FastCGI互相通信。 你需要做两件事：
    使用 FastCGIExternalServer 指明FastCGI的位置。
    使用 mod_rewrite 为FastCGI指定合适的URL。

##指定 FastCGI Server 的位置
FastCGIExternalServer 告诉Apache如何找到FastCGI服务器。
以下是两个例子：
# Connect to FastCGI via a socket/named pipe:
FastCGIExternalServer /home/user/public_html/mysite.fcgi -socket /home/user/mysite.sock
# Connect to FastCGI via a TCP host/port:
FastCGIExternalServer /home/user/public_html/mysite.fcgi -host 127.0.0.1:3033
在这两个例子中， /home/user/public_html/ 目录必须存在，而 /home/user/public_html/mysite.fcgi 文件不一定存在。 它仅仅是一个Web服务器内部使用的接口，这个URL决定了对于哪些URL的请求会被FastCGI处理

##使用mod_rewrite为FastCGI指定URL
第二步是告诉Apache为符合一定模式的URL使用FastCGI。 为了实现这一点，请使用mod_rewrite 模块，并将这些URL重定向到 mysite.fcgi （或者正如在前文中描述的那样，使用任何在 FastCGIExternalServer 指定的内容）。

在这个例子里面，我们告诉Apache使用FastCGI来处理那些在文件系统上不提供文件(译者注：

<VirtualHost 12.34.56.78>
  ServerName example.com
  DocumentRoot /home/user/public_html
  Alias /media /home/user/python/django/contrib/admin/media
  RewriteEngine On
  RewriteRule ^/(media.*)$ /$1 [QSA,L]
  RewriteCond %{REQUEST_FILENAME} !-f
  RewriteRule ^/(.*)$ /mysite.fcgi/$1 [QSA,L]
</VirtualHost>

【FastCGI 和 lighttpd】
lighttpd (http://www.djangoproject.com/r/lighttpd/) 是一个轻量级的Web服务器，通常被用来提供静态页面的访问。 它天生支持FastCGI，因此除非你的站点需要一些Apache特有的特性，否则，lighttpd对于静态和动态页面来说都是理想的选择。

确保 mod_fastcgi 在模块列表中，它需要出现在 mod_rewrite 和 mod_access ，但是要在 mod_accesslog 之前。

将下面的内容添加到你的lighttpd的配置文件中：

server.document-root = "/home/user/public_html"
fastcgi.server = (
    "/mysite.fcgi" => (
        "main" => (
            # Use host / port instead of socket for TCP fastcgi
            # "host" => "127.0.0.1",
            # "port" => 3033,
            "socket" => "/home/user/mysite.sock",
            "check-local" => "disable",
        )
    ),
)
alias.url = (
    "/media/" => "/home/user/django/contrib/admin/media/",
)

url.rewrite-once = (
    "^(/media.*)$" => "$1",
    "^/favicon\.ico$" => "/media/favicon.ico",
    "^(/.*)$" => "/mysite.fcgi$1",
)

##在一个lighttpd进程中运行多个Django站点
lighttpd允许你使用条件配置来为每个站点分别提供设置。 为了支持FastCGI的多站点，只需要在FastCGI的配置文件中，为每个站点分别建立条件配置项：
1

# If the hostname is 'www.example1.com'...
$HTTP["host"] == "www.example1.com" {
    server.document-root = "/foo/site1"
    fastcgi.server = (
       ...
    )
    ...
}

# If the hostname is 'www.example2.com'...
$HTTP["host"] == "www.example2.com" {
    server.document-root = "/foo/site2"
    fastcgi.server = (
       ...
    )
    ...
}

你也可以通过 fastcgi.server 中指定多个入口，在同一个站点上实现多个Django安装。 请为每一个安装指定一个FastCGI主机。

