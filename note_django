

__init__.py ：让 Python 把该目录当成一个开发包 (即一组模块)所需的文件。 这是一个空文件，一般你不需要修改它。

manage.py ：一种命令行工具，允许你以多种方式与该 Django 项目进行交互。 键入python manage.py help，看一下它能做什么。 你应当不需要编辑这个文件；在这个目录下生成它纯是为了方便。

settings.py ：该 Django 项目的设置或配置。 查看并理解这个文件中可用的设置类型及其默认值。

urls.py：Django项目的URL设置。 可视其为你的django网站的目录。 目前，它是空的。

页面的内容是靠view function（视图函数） 来产生，URL定义在 URLconf 中.一个视图就是Python的一个函数。这个函数第一个参数的类型是HttpRequest；它返回一个HttpResponse实例。为了使一个Python的函数成为一个Django可识别的视图，它必须满足这两个条件。 （也有例外，但是我们稍后才会接触到。

匹配网站根目录的URL模式, ('^$', my_homepage_view)

【模板系统：HTML模板】
Django模板系统的基本规则： 写模板，创建 Template 对象，创建 Context ， 调用 render() 方法。

from django import template
t = template.Template('my name is {{ name }}.')
c = template.Context({'name': 'Ada'})
t.render(c)
Out[6]:
'my name is Ada.'

【编写模板并渲染的示例：】
>>> from django.template import Template, Context
>>> raw_template = """<p>Dear {{ person_name }},</p>
...
... <p>Thanks for placing an order from {{ company }}. It's scheduled to
... ship on {{ ship_date|date:"F j, Y" }}.</p>
...
... {% if ordered_warranty %}
... <p>Your warranty information will be included in the packaging.</p>
... {% else %}
... <p>You didn't order a warranty, so you're on your own when
... the products inevitably stop working.</p>
... {% endif %}
...
... <p>Sincerely,<br />{{ company }}</p>"""
>>> t = Template(raw_template)
>>> import datetime
>>> c = Context({'person_name': 'John Smith',
...     'company': 'Outdoor Equipment',
...     'ship_date': datetime.date(2009, 4, 2),
...     'ordered_warranty': False})
>>> t.render(c)
u"<p>Dear John Smith,</p>\n\n<p>Thanks for placing an order from Outdoor
Equipment. It's scheduled to\nship on April 2, 2009.</p>\n\n\n<p>You
didn't order a warranty, so you're on your own when\nthe products
inevitably stop working.</p>\n\n\n<p>Sincerely,<br />Outdoor Equipment
</p>"

【一旦有了 模板 对象，你就可以通过它渲染多个context】， 例如：
t = Template('Hello, {{ name }}')
for name in ('John', 'Julie', 'Pat'):
    print t.render(Context({'name': name}))

 比如，假设你要向模板传递一个 Python 字典。 要通过字典键访问该字典的值:
 >>> from django.template import Template, Context
>>> person = {'name': 'Sally', 'age': '43'}
>>> t = Template('{{ person.name }} is {{ person.age }} years old.')
>>> c = Context({'person': person})
>>> t.render(c)
u'Sally is 43 years old.'

【也可以通过句点来访问对象的属性。】 比方说， Python 的 datetime.date 对象有 year 、 month 和 day 几个属性，你同样可以在模板中使用句点来访问这些属性：
>>> t = Template('The month is {{ date.month }} and the year is {{ date.year }}.')
>>> c = Context({'date': d})
>>> t.render(c)
u'The month is 5 and the year is 1993.'

【自定义类：】
class Person():
    def __init__(self, firstName, lastName):
        self.firstName, self.lastName = firstName, lastName

t = template.Template('hello, {{person.firstName}} {{person.lastName}}.')
c = template.Context({'person': Person('john', 'Smith')})
t.render(c)
Out[16]:
'hello, john Smith.'

【点语法也可以用来引用对象的* 方法*。】 例如，每个 Python 字符串都有 upper() 和 isdigit() 方法，你在模板中可以使用同样的句点语法来调用它们：
t = template.Template('{{ var }} -- {{ var.upper }} -- {{ var.isdigit }}')
c = template.Context({'var': 'hello'})
t.render(c)
Out[19]:
'hello -- HELLO -- False'
t.render(template.Context({'var': '123'}))
Out[20]:
'123 -- 123 -- True'
注意这里调用方法时并* 没有* 使用圆括号 而且也无法给该方法传递参数；你只能调用不需参数的方法。

【句点也可用于访问列表索引:】
>>> from django.template import Template, Context
>>> t = Template('Item 2 is {{ items.2 }}.')
>>> c = Context({'items': ['apples', 'bananas', 'carrots']})
>>> t.render(c)
'Item 2 is carrots.'
不允许使用负数列表索引。 像 {{ items.-1 }} 这样的模板变量将会引发`` TemplateSyntaxError``

句点查找规则可概括为： 当模板系统在变量名中遇到点时，按照以下顺序尝试进行查找：
    字典类型查找 （比如 foo["bar"] )
    属性查找 (比如 foo.bar )
    方法调用 （比如 foo.bar() )
    列表类型索引查找 (比如 foo[bar] )
系统使用找到的第一个有效类型.

【句点查找可以多级深度嵌套】。 例如在下面这个例子中 {{person.name.upper}} 会转换成字典类型查找（ person['name'] ) 然后是方法调用（ upper() ):
>>> from django.template import Template, Context
>>> person = {'name': 'Sally', 'age': '43'}
>>> t = Template('{{ person.name.upper }} is {{ person.age }} years old.')
>>> c = Context({'person': person})
>>> t.render(c)
'SALLY is 43 years old.'

默认情况下，如果一个变量不存在，模板系统会把它展示为空字符串，不做任何事情来表示失败。

多数时间，你可以通过传递一个完全填充(full populated)的字典给 Context() 来初始化 上下文(Context) 。 但是初始化以后，你也可以使用标准的Python字典语法(syntax)向``上下文(Context)`` 对象添加或者删除条目.
>>> c = Context({"foo": "bar"})
>>> c['foo']
'bar'
>>> del c['foo']
>>> c['foo']
Traceback (most recent call last):

【标签】
{% if %} 标签接受 and ， or 或者 not 关键字来对多个变量做判断 ，或者对变量取反（ not )，不允许在同一个标签中同时使用 and 和 or.系统不支持用圆括号来组合比较操作。
一定要用 {% endif %} 关闭每一个 {% if %} 标签。

{% for %}允许我们在一个序列上迭代. 每一次循环中，模板系统会渲染在 {% for %} 和 {% endfor %} 之间的所有内容。
<ul>
{% for athlete in athlete_list %}
    <li>{{ athlete.name }}</li>
{% endfor %}
</ul>

给标签增加一个 reversed 使得该列表被反向迭代：
{% for athlete in athlete_list reversed %}
...
{% endfor %}

`` for`` 标签支持一个可选的`` {% empty %}`` 分句:
{% for athlete in athlete_list %}
    <p>{{ athlete.name }}</p>
{% empty %}
    <p>There are no athletes. Only computer programmers.</p>
{% endfor %}

Django不支持退出循环操作。 如果我们想退出循环，可以改变正在迭代的变量。Django也不支持continue语句，我们无法让当前迭代操作跳回到循环头部。

forloop 变量仅仅能够在循环中使用。 在模板解析器碰到{% endfor %}标签后，forloop就不可访问了。
forloop.counter 总是一个表示当前循环的执行次数的整数计数器。 这个计数器是从1开始的。
{% for item in todo_list %}
    <p>{{ forloop.counter }}: {{ item }}</p>
{% endfor %}
forloop.counter0 类似于 forloop.counter ，但是它是从0计数的。 第一次执行循环时这个变量会被设置为0。
forloop.revcounter 是表示循环中剩余项的整型变量。 在循环初次执行时 forloop.revcounter 将被设置为序列中项的总数。 最后一次循环执行中，这个变量将被置1。
forloop.revcounter0 类似于 forloop.revcounter ，但它以0做为结束索引。 在第一次执行循环时，该变量会被置为序列的项的个数减1。
forloop.first 是一个布尔值，如果该迭代是第一次执行，那么它被置为True。
forloop.last 是一个布尔值；在最后一次执行循环时被置为True。
forloop.parentloop 是一个指向当前循环的上一级循环的 forloop 对象的引用（在嵌套循环的情况下）。

【ifequal/ifnotequal】
{% ifequal %} 标签比较两个值，当他们相等时，显示在 {% ifequal %} 和 {% endifequal %} 之中所有的值。只有模板变量，字符串，整数和小数可以作为 {% ifequal %} 标签的参数。
下面的例子比较两个模板变量 user 和 currentuser :
{% ifequal user currentuser %}
    <h1>Welcome!</h1>
{% endifequal %}

参数可以是硬编码的字符串，随便用单引号或者双引号引起来，所以下列代码都是正确的：
{% ifequal section 'sitenews' %}
    <h1>Site News</h1>
{% endifequal %}

{% ifequal section "community" %}
    <h1>Community</h1>
{% endifequal %}

和 {% if %} 类似， {% ifequal %} 支持可选的 {% else%} 标签：
{% ifequal section 'sitenews' %}
    <h1>Site News</h1>
{% else %}
    <h1>No News Here</h1>
{% endifequal %}

【注释】
Django模板语言同样提供代码注释。 注释的内容不会在模板渲染时输出。注释使用 {# #} ：
{# This is a comment #}

多行注释，可以使用`` {% comment %}`` 模板标签：
{% comment %}
This is a
multi-line comment.
{% endcomment %}

【过滤器】
过滤器使用管道字符。如 {{ name|lower }} ，显示的内容是变量 {{ name }} 被过滤器 lower 处理后的结果，它功能是转换文本为小写。

{{ my_list|first|upper }} 实现查找列表的第一个元素并将其转化为大写。

有些过滤器有参数。 过滤器的参数跟随冒号之后并且总是以双引号包含。 例如：{{ bio|truncatewords:"30" }} ，将显示变量 bio 的前30个词。

addslashes : 添加反斜杠到任何反斜杠、单引号或者双引号前面。 这在处理包含JavaScript的文本时是非常有用的。
date : 按指定的格式字符串参数格式化 date 或者 datetime 对象， 范例：{{ pub_date|date:"F j, Y" }}
length : 返回变量的长度。 对于列表，这个参数将返回列表元素的个数。 对于字符串，这个参数将返回字符串中字符的个数。 你可以对列表或者字符串，或者任何知道怎么测定长度的Python 对象使用这个方法。

【模板加载】
见views.py
方法二，通过get_template导入模板
方法三，通过django.shortcuts的render_to_response模块直接返回数据。

locals() 技巧
我们没有像之前那样手工指定 context 字典，而是传入了 locals() 的值，它囊括了函数执行到该时间点时所定义的一切变量。 因此，我们将 now 变量重命名为 current_date ，因为那才是模板所预期的变量名称。
使用 locals() 时要注意是它将包括 所有 的局部变量，它们可能比你想让模板访问的要多。 在前例中， locals() 还包含了 request 。
def current_datetime(request):
    now = datetime.datetime.now()
    return render_to_response('current_datetime.html', {'current_date': now})
可写为
def current_datetime(request):
    current_date = datetime.datetime.now()
    return render_to_response('current_datetime.html', locals())

【get_template()中使用子目录】
只需在调用 get_template() 时，把子目录名和一条斜杠添加到模板名称之前。对子目录树的深度没有限制。
t = get_template('dateapp/current_datetime.html')
return render_to_response('dateapp/current_datetime.html', {'current_date': now})

【include 模板标签】
{% include %}该标签允许在（模板中）包含其它的模板的内容。 标签的参数是所要包含的模板名称，可以是一个变量，也可以是用单/双引号硬编码的字符串。
{% include 'nav.html' %}
{% include "nav.html" %}
{% include 'includes/nav.html' %}
{% include template_name %}  以变量 template_name 的值为名称的模板

【模板继承】
可以对那些 不同 的代码段进行定义，而不是 共同 代码段。见base.html
见views.py的current_datetime和hours_ahead函数，注意函数中的变量需要与对应的html中的变量相匹配。
对应的html文件中{% extends %} 标签注明此为子模板。
由于子模板并没有定义 footer 块，模板系统将使用在父模板中定义的值。 父模板 {% block %} 标签中的内容总是被当作一条退路。

使用继承的一种常见方式是下面的三层法：
1，创建 base.html 模板，在其中定义站点的主要外观感受。 这些都是不常修改甚至从不修改的部分。
2，为网站的每个区域创建 base_SECTION.html 模板(例如, base_photos.html 和 base_forum.html )。这些模板对 base.html 进行拓展，并包含区域特定的风格与设计。
3，为每种类型的页面创建独立的模板，例如论坛页面或者图片库。 这些模板拓展相应的区域模板。

使用模板继承的一些诀窍：
1，如果在模板中使用 {% extends %} ，必须保证其为模板中的第一个模板标记。 否则，模板继承将不起作用。
2，基础模板中的 {% block %} 标签越多越好。 记住，子模板不必定义父模板中所有的代码块，因此你可以用合理的缺省值对一些代码块进行填充，然后只对子模板所需的代码块进行（重）定义。
3，如果发觉自己在多个模板之间拷贝代码，你应该考虑将该代码段放置到父模板的某个 {% block %} 中。
4，如果你需要访问父模板中的块的内容，使用 {{ block.super }}这个标签吧，这一个魔法变量将会表现出父模板中的内容。 如果只想在上级代码块基础上添加内容，而不是全部重载，该变量就显得非常有用了
5,不允许在同一个模板中定义多个同名的 {% block %}
6,{% extends %} 对所传入模板名称使用的加载方法和 get_template() 相同。 也就是说，会将模板名称被添加到 TEMPLATE_DIRS 设置之后。
7,多数情况下， {% extends %} 的参数应该是字符串，但是如果直到运行时方能确定父模板名，这个参数也可以是个变量。 这使得你能够实现一些很酷的动态功能。


【模型】
 MVC 模式，可以称得上是一种 MVC 框架。 以下是 Django 中 M、V 和 C 各自的含义：
M ，数据存取部分，由django数据库层处理，本章要讲述的内容。
V ，选择显示哪些数据要显示以及怎样显示的部分，由视图和模板处理。
C ，根据用户输入委派视图的部分，由 Django 框架根据 URLconf 设置，对给定 URL 调用适当的 Python 函数。

由于 C 由框架自行处理，而 Django 里更关注的是模型（Model）、模板(Template)和视图（Views），Django 也被称为 MTV 框架 。在 MTV 开发模式中：
M 代表模型（Model），即数据存取层。 该层处理与数据相关的所有事务： 如何存取、如何验证有效性、包含哪些行为以及数据之间的关系等。
T 代表模板(Template)，即表现层。 该层处理与表现相关的决定： 如何在页面或其他类型文档中进行显示。
V 代表视图（View），即业务逻辑层。 该层包含存取模型及调取恰当模板的相关逻辑。 你可以把它看作模型与模板之间的桥梁。

【连接mysql配置】
修改settings.py中的DATABASE字典中的配置。
安装mysqlclient，作为python和Django的接口。
进入python manage.py shell，测试配置。
>>> from django.db import connection
>>> cursor = connection.cursor()

【第一个应用程序APP】
 project 和 app区别就是一个是配置另一个是 代码。一个project包含很多个Django app以及对它们的配置。
技术上，project的作用是提供配置文件，比方说哪里定义数据库连接信息, 安装的app列表， TEMPLATE_DIRS ，等等。
一个app是一套Django功能的集合，通常包括模型和视图，按Python的包结构的方式存在。
例如，Django本身内建有一些app，例如注释系统和自动管理界面。 app的一个关键点是它们是很容易移植到其他project和被多个project复用。
系统对app有一个约定： 如果你使用了Django的数据库层（模型），你 必须创建一个Django app。 模型必须存放在apps中。

新建APP：python manage.py startapp books  会生成books文件夹并包含一些初始文件。

【第一个模型】
“每个数据库表对应一个类”这条规则的例外情况是多对多关系。 在我们的范例模型中， Book 有一个 多对多字段 叫做 authors 。 该字段表明一本书籍有一个或多个作者，但 Book 数据库表却并没有 authors 字段。 相反，Django创建了一个额外的表（多对多连接表）来处理书籍和作者之间的映射关系。
最后需要注意的是，我们并没有显式地为这些模型定义任何主键。 除非你单独指明，否则Django会自动为每个模型生成一个自增长的整数主键字段每个Django模型都要求有单独的主键。id

{以下为1.10.0版本操作，与老版本不同}
编辑 settings.py 文件， 找到 INSTALLED_APPS 设置。添加`` ‘books’`` 到`` INSTALLED_APPS`` 的末尾。
执行如下命令生成数据库表：
1,python manage.py check  检查模型的语法和逻辑是否正确。
2,python manage.py makemigrations 用来检测数据库变更和生成数据库迁移文件
3,python manage.py sqlmigrate demo 0001 用来把数据库迁移文件转换成数据库语言,demo指app名称
4,python manage.py migrate 用于执行迁移动作
注：如果更改models.py内容后，需要重新执行以上命令使数据库内生效。

python manage.py shell 中执行：
>>> p1 = Publisher(name='Apress', address='2855 Telegraph Avenue',
...     city='Berkeley', state_province='CA', country='U.S.A.',
...     website='http://www.apress.com/')
>>> p1.save()       #Django 会在后台执行一条 INSERT 语句。
>>> p2 = Publisher.objects.create(name="O'Reilly",
...     address='10 Fawcett St.', city='Cambridge',
...     state_province='MA', country='U.S.A.',
...     website='http://www.oreilly.com/')      #使用`` objects.create()`` 方法,可以一步完成对象的创建与存储至数据库。
>>> publisher_list      #Django执行了一条SQL `` SELECT`` 语句。
[<Publisher: Publisher object>, <Publisher: Publisher object>]

解决以上输出中Publisher object解码问题，需要在models.py中的每个类中添加 def __str__(): 方法。老版本为添加__unicode__()。
退出manage.py shell后，重新进入
In [1]: from books.models import Publisher
In [2]: Publisher.objects.all()
Out[2]: <QuerySet [<Publisher: Apress>, <Publisher: O'Reilly>, <Publisher: O'Reilly>]>

更新数据库内容：
In [3]: p = Publisher(name='Apress',
   ...:          address='2855 Telegraph Ave.',
   ...:          city='Berkeley',
   ...:          state_province='CA',
   ...:          country='U.S.A.',
   ...:          website='http://www.apress.com/')
In [4]: p.save()
In [5]: p.id
Out[5]: 4
In [6]: p.name = 'Apress Publishing'
In [7]: p.save()
In [8]: p.name
Out[8]: 'Apress Publishing'

数据查询：
调用绑定在该模型上的管理器(objects)的相应方法(如all)。

数据过滤：
>>> Publisher.objects.filter(name='Apress')     #使用filter()
[<Publisher: Apress>]
>>> Publisher.objects.filter(country="U.S.A.", state_province="CA")
[<Publisher: Apress>]
>>> Publisher.objects.filter(name__contains="press")        #相当于mysql中的LIKE，name__contains为双下划线，代表模糊匹配
[<Publisher: Apress>]
其他包括icontains(大小写无关的LIKE),startswith和endswith, 还有range(SQLBETWEEN查询）等。

获取单个对象：
>>> Publisher.objects.get(name="Apress")
<Publisher: Apress>
返回了单个对象，而不是列表（更准确的说，QuerySet)。 所以，如果结果是多个对象，会导致抛出异常。
DoesNotExist 异常 是 Publisher 这个 model 类的一个属性，即 Publisher.DoesNotExist。在你的应用中，你可以捕获并处理这个异常，像这样：
try:
    p = Publisher.objects.get(name='Apress')
except Publisher.DoesNotExist:
    print "Apress isn't in the database yet."
else:
    print "Apress is in the database."

数据排序：
>>> Publisher.objects.order_by("name")
[<Publisher: Apress>, <Publisher: O'Reilly>]
按字母顺序。可以对任意字段进行排序。
>>> Publisher.objects.order_by("state_province", "address")     以多个字段为标准进行排序（第二个字段会在第一个字段的值相同的情况下被使用到），使用多个参数就可以。
 [<Publisher: Apress>, <Publisher: O'Reilly>]
 >>> Publisher.objects.order_by("-name")        #逆向排序，在前面加一个减号 - 前缀。
[<Publisher: O'Reilly>, <Publisher: Apress>]
添加默认排序，可以使用class Meta，参见books/models.py中的Publisher类中的class Meta

连锁查询：
>>> Publisher.objects.filter(country="U.S.A.").order_by("-name")
[<Publisher: O'Reilly>, <Publisher: Apress>]

限制返回的数据：
>>> Publisher.objects.order_by('name')[0]       #等于mysql中的LIMIT 1
<Publisher: Apress>
>>> Publisher.objects.order_by('name')[0:2]     #相当于python的切片显示
注意，不支持Python的负索引，如Publisher.objects.order_by('name')[-1]。但可以通过下面方式从尾部取数据blisher.objects.order_by('-name')[0]

更新指定对象值：
上述的方法
>>> p = Publisher.objects.get(name='Apress')
>>> p.name = 'Apress Publishing'
>>> p.save()
相当于
SELECT id, name, address, city, state_province, country, website
FROM books_publisher
WHERE name = 'Apress';

UPDATE books_publisher SET
    name = 'Apress Publishing',
    address = '2855 Telegraph Ave.',
    city = 'Berkeley',
    state_province = 'CA',
    country = 'U.S.A.',
    website = 'http://www.apress.com'
WHERE id = 52;
即会更新所有数据，如果此数据中的列正被其他进程修改，则造成影响。
正确且高效的方法是使用update()。相当于MYSQL的
UPDATE books_publisher
SET name = 'Apress Publishing'
WHERE id = 52;
>>> Publisher.objects.filter(id=52).update(name='Apress Publishing')        #更新条件限定的一条数据
>>> Publisher.objects.all().update(country='USA')       #更新所有数据
2       #返回值为受影响的条目。

删除对象：
>>> p = Publisher.objects.get(name="O'Reilly")
>>> p.delete()
>>> Publisher.objects.all()
[<Publisher: Apress Publishing>]
同样我们可以在结果集上调用delete()方法同时删除多条记录。
>>> Publisher.objects.filter(country='USA').delete()
>>> Publisher.objects.all().delete()        #删除所有数据
>>> Publisher.objects.all()
[]


【【web管理界面】】
首先确认settings中INSTALLED_APPS和MIDDLEWARE中相关contrib插件没有被删改。
创建超级账户。运行
python manage.py makemigrations
python manage.py createsuperuser
启动服务器。

【修改语言】：
在settings中的MIDDLEWARE字典中加入'django.middleware.locale.LocaleMiddleware'

【将你的Models加入到Admin管理中】
编辑app下的admin.py,添加
from books.models import Publisher, Book, Author

admin.site.register(Publisher)
admin.site.register(Book)
admin.site.register(Author)

【设置字段可选】
books/models.py文件里,class Author(models.Model):中email = models.EmailField(blank=True)。这些代码告诉Django，作者的邮箱地址允许输入一个空值。 所有字段都默认blank=False，这使得它们不允许输入空值。

【设置日期型和数字型字段可选】
日期型、时间型和数字型字段不接受空字符串。在Django模块中，你可以通过添加null=True来指定一个字段允许为NULL。如果你想允许一个日期型或数字型字段为空，你需要使用null=True  和 blank=True。
class Book(models.Model):
    title = models.CharField(max_length=100)
    authors = models.ManyToManyField(Author)
    publisher = models.ForeignKey(Publisher)
    publication_date = models.DateField(blank=True, null=True)
上述代码的null=True。
此操作需要重新生成数据库。

【自定义字段标签】
在编辑页面中，每个字段的标签都是从模块的字段名称生成的。 规则很简单： 用空格替换下划线；首字母大写。例如：Book模块中publication_date的标签是Publication date。
自定义标签名方法：email = models.EmailField(blank=True, verbose_name='e-mail' )

【自定义ModelAdmin类】
在models.py中添加class AuthorAdmin(admin.ModelAdmin):
    list_display = ('first_name', 'last_name', 'email')，修改admin.site.register(Author, AuthorAdmin)后，刷新浏览器，会在Author标签页中看到出现了设置的标签列，页面顶端看到一个查询栏。
search_fields = ('first_name', 'last_name'),添加搜索框
list_filter = ('publication_date', )，页面右侧添加过滤器，为日期型字段提供了快捷过滤方式，它包含：今天、过往七天、当月和今年。
`` 过滤器`` 同样适用于其它类型的字段，而不单是`` 日期型`` （请在`` 布尔型`` 和`` 外键`` 字段上试试）。当有两个以上值时，过滤器就会显示。
date_hierarchy = 'publication_date',date_hierarchy接受的是* 字符串* ，而不是元组。因为只能对一个日期型字段进行层次划分。页面中的列表顶端会有一个逐层深入的导航条，效果如图 6-11. 它从可用的年份开始，然后逐层细分到月乃至日。
ordering = ('-publication_date', ),以publication_date倒序显示

【自定义编辑表单】
在admin.py中的类中修改
fields = ('title', 'authors', 'publisher', 'publication_date')，编辑表单将按照指定的顺序显示各字段。
fields = ('title', 'authors', 'publisher')，隐藏了'publication_date'，可以排除一些不想被其他人编辑的fields。在编辑页面就无法对publication date进行改动。
filter_horizontal = ('authors',),对‘多对多选项’优化，当选项过多时，方便选中所需项。只能用在多对多字段 上, 而不能用于 ForeignKey字段。（filter_vertical用处类似，为竖排展现外观）
raw_id_fields = ('publisher',),修改外键默认的下拉框展现方式，如数据过多，加载下拉框时间过长，使用该参数可以改为文本框，输入键值ID即可。

【用户、用户组和权限】
界面上配置


##表单##
介绍对用户通过表单提交的数据进行访问、有效性检查以及其它处理

【从Request对象中获取数据】
HttpRequest对象包含当前请求URL的一些信息：
属性/方法 	说明 	举例
request.path 	除域名以外的请求路径，以正斜杠开头 	"/hello/"
request.get_host() 	主机名（比如，通常所说的域名） 	"127.0.0.1:8000" or "www.example.com"
request.get_full_path() 	请求路径，可能包含查询字符串 	"/hello/?print=true"
request.is_secure() 	如果通过HTTPS访问，则此方法返回True， 否则返回False 	True 或者 False

在view函数里，要始终用这个属性或方法来得到URL，而不要手动输入：
# BAD!
def current_url_view_bad(request):
    return HttpResponse("Welcome to the page at /current/")

# GOOD
def current_url_view_good(request):
    return HttpResponse("Welcome to the page at %s" % request.path)

request.META 是一个Python字典，包含了所有本次HTTP请求的Header信息，比如用户IP地址和用户Agent（通常是浏览器的名称和版本号）。即基本的元数据。 注意，Header信息的完整列表取决于用户所发送的Header信息和服务器端设置的Header信息。 这个字典中几个常见的键值有：
    HTTP_REFERER，进站前链接网页，如果有的话。 （请注意，它是REFERRER的笔误。）
    HTTP_USER_AGENT，用户浏览器的user-agent字符串，如果有的话。 例如： "Mozilla/5.0 (X11; U; Linux i686; fr-FR; rv:1.8.1.17) Gecko/20080829 Firefox/2.0.0.17" .
    REMOTE_ADDR 客户端IP，如："12.345.67.89" 。(如果申请是经过代理服务器的话，那么它可能是以逗号分割的多个IP地址，如："12.345.67.89,23.456.78.90" 。

因为 request.META 是一个普通的Python字典，因此当你试图访问一个不存在的键时，会触发一个KeyError异常。
# BAD!
def ua_display_bad(request):
    ua = request.META['HTTP_USER_AGENT']  # Might raise KeyError!
    return HttpResponse("Your browser is %s" % ua)

# GOOD (VERSION 1)
def ua_display_good1(request):
    try:
        ua = request.META['HTTP_USER_AGENT']
    except KeyError:
        ua = 'unknown'
    return HttpResponse("Your browser is %s" % ua)

# GOOD (VERSION 2)
def ua_display_good2(request):
    ua = request.META.get('HTTP_USER_AGENT', 'unknown')
    return HttpResponse("Your browser is %s" % ua)

request.META返回的所有数据，可见Django/views.py下的def display_meta(request)即相关urls.py中添加的对应url

【提交的数据信息】
“request.GET和request.POST是类字典对象”,request.GET和request.POST都有get()、keys()和values()方法，也拥有一些普通的字典对象所没有的方法。
POST数据是来自HTML中的〈form〉标签提交的，而GET数据可能来自〈form〉提交也可能是URL中的查询字符串(the query string)。

【简单的例子】
books/views.py中search_form和search方法，templates中的search_form.html模板，制作了一个search框功能。

【POST与GET之间有什么不同？】
当我们提交表单仅仅需要获取数据时就可以用GET； 而当我们提交表单时需要更改服务器数据的状态，或者说发送e-mail，或者其他不仅仅是获取并显示数据的时候就使用POST。 在这个搜索书籍的例子里，我们使用GET，因为这个查询不会更改服务器数据的状态。

